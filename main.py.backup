import sys
import os
import json
import time
import random
import threading
import emoji
import pyautogui
import pyperclip
import ctypes
from typing import Dict, List
# Testing file edit
from PyQt5.QtWidgets import (QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, 
                QPushButton, QLabel, QSlider, QTextEdit, QFrame, QCheckBox,
                QDialog, QMenu, QAction, QMenuBar, QProgressBar, QMessageBox, QToolTip,
                QGraphicsOpacityEffect, QListWidget, QInputDialog)
from PyQt5.QtGui import QIcon, QFont, QPixmap, QColor, QPalette, QPainter, QTextCursor
from PyQt5.QtCore import Qt, QThread, pyqtSignal, QTimer, QRect, QPoint, QPropertyAnimation, QEasingCurve

# Import personality modules
from bot_personality import BotPersonality
from personality_dialog import PersonalityDialog

pyautogui.PAUSE = 0  # Remove default pause between actions for max speed
pyautogui.FAILSAFE = False  # Disable fail-safe for smoother operation

# Windows API for window handling
user32 = ctypes.windll.user32

# Windows constants for SendMessage/PostMessage
WM_CHAR = 0x0102
WM_KEYDOWN = 0x0100
WM_KEYUP = 0x0101
VK_RETURN = 0x0D
VK_BACK = 0x08
VK_TAB = 0x09
VK_SHIFT = 0x10
VK_CONTROL = 0x11

# Common misspellings dictionary 
AUTOCORRECT_DICT = {
    "teh": "the",
    "adn": "and",
    "waht": "what",
    "taht": "that",
    "thier": "their",
    "recieve": "receive",
    "wierd": "weird",
    "alot": "a lot",
    "definately": "definitely",
    "seperate": "separate",
    "occured": "occurred",
    "occurance": "occurrence",
    "greatful": "grateful",
    "accomodate": "accommodate",
    "untill": "until",
    "doesnt": "doesn't",
    "dont": "don't",
    "cant": "can't",
    "wont": "won't",
    "shouldnt": "shouldn't",
    "couldnt": "couldn't",
    "wouldnt": "wouldn't",
    "isnt": "isn't",
    "wasnt": "wasn't",
    "werent": "weren't",
    "havent": "haven't",
    "hasnt": "hasn't",
    "didnt": "didn't",
    "im": "I'm",
    "ive": "I've",
    "youre": "you're",
    "theyre": "they're",
    "weve": "we've",
    "theyve": "they've",
    "cant": "can't",
    "wouldve": "would've",
    "shouldve": "should've",
    "couldve": "could've",
    "mispell": "misspell",
    "beleive": "believe",
    "acheive": "achieve",
    "reccomend": "recommend",
    "tommorrow": "tomorrow",
    "advertisment": "advertisement",
    "neccessary": "necessary",
    "occasionaly": "occasionally",
    "embarass": "embarrass",
    "concious": "conscious",
    "truely": "truly",
    "rigth": "right",
}

# Special character replacements - maps fancy characters to standard equivalents
SPECIAL_CHAR_REPLACEMENTS = {
    # Smart quotes and apostrophes
    ''': "'",    # Left single quote
    ''': "'",    # Right single quote
    '"': '"',    # Left double quote
    '"': '"',    # Right double quote
    '‚': ',',    # Single low-9 quotation mark
    '„': '"',    # Double low-9 quotation mark
    
    # Dashes and hyphens
    '–': '-',    # En dash
    '—': '--',   # Em dash
    '−': '-',    # Minus sign
    '‐': '-',    # Hyphen
    '‑': '-',    # Non-breaking hyphen
    '‒': '-',    # Figure dash
    '⁃': '-',    # Hyphen bullet
    
    # Spaces
    ' ': ' ',    # Non-breaking space
    '  ': ' ',   # En space
    '   ': ' ',  # Em space
    
    # Fractions
    '½': '1/2',
    '⅓': '1/3',
    '⅔': '2/3',
    '¼': '1/4',
    '¾': '3/4',
    '⅕': '1/5',
    '⅖': '2/5',
    '⅗': '3/5',
    '⅘': '4/5',
    '⅙': '1/6',
    '⅚': '5/6',
    '⅛': '1/8',
    '⅜': '3/8',
    '⅝': '5/8',
    '⅞': '7/8',
    
    # Arrows
    '←': '<-',
    '→': '->',
    '↑': '^',
    '↓': 'v',
    '↔': '<->',
    '⇐': '<=',
    '⇒': '=>',
    '⇑': '=>',
    '⇓': '=>',
    '⇔': '<=>',
    
    # Mathematical symbols
    '×': 'x',
    '÷': '/',
    '±': '+/-',
    '∞': 'infinity',
    '≈': '~=',
    '≠': '!=',
    '≤': '<=',
    '≥': '>=',
    '∑': 'sum',
    '∏': 'product',
    '∂': 'd',
    '∫': 'integral',
    '∆': 'delta',
    '∇': 'nabla',
    '√': 'sqrt',
    '∛': 'cbrt',
    '∝': 'proportional to',
    '∩': 'intersection',
    '∪': 'union',
    '∈': 'in',
    '∉': 'not in',
    '∅': 'empty set',
    '∀': 'for all',
    '∃': 'there exists',
    '∄': 'there does not exist',
    '∵': 'because',
    '∴': 'therefore',
    
    # Currency symbols
    '€': 'EUR',
    '£': 'GBP',
    '¥': 'JPY',
    '₹': 'INR',
    '₽': 'RUB',
    '¢': 'cents',
    
    # Other symbols
    '©': '(c)',
    '®': '(R)',
    '™': '(TM)',
    '°': ' degrees',
    '•': '*',
    '·': '-',
    '…': '...',
    '℅': 'c/o',
    '℃': 'C',
    '℉': 'F',
    '№': 'No.',
    '℗': '(P)',
    '℠': '(SM)',
    '✓': 'check',
    '✔': 'check',
    '✕': 'x',
    '✖': 'x',
    '✗': 'x',
    '✘': 'x',
}

class WordMemory:
    """Tracks word familiarity and calculates typing confidence scores."""
    
    def __init__(self, memory_file="word_memory.json"):
        self.memory_file = memory_file
        self.memory = self.load_memory()
        self.lock = threading.Lock()  # Add lock for thread safety
        self.common_words = {"the",
            "be",
            "to",
            "of",
            "and",
            "a",
            "in",
            "that",
            "have",
            "I",
            "it",
            "for",
            "not",
            "on",
            "with",
            "he",
            "as",
            "you",
            "do",
            "at",
            "this",
            "but",
            "his",
            "by",
            "from",
            "they",
            "we",
            "say",
            "her",
            "she",
            "or",
            "an",
            "will",
            "my",
            "one",
            "all",
            "would",
            "there",
            "their",
            "what",
            "so",
            "up",
            "out",
            "if",
            "about",
            "who",
            "get",
            "which",
            "go",
            "me",
            "when",
            "make",
            "can",
            "like",
            "time",
            "no",
            "just",
            "him",
            "know",
            "take",
            "people",
            "into",
            "year",
            "your",
            "good",
            "some",
            "could",
            "them",
            "see",
            "other",
            "than",
            "then",
            "now",
            "look",
            "only",
            "come",
            "its",
            "over",
            "think",
            "also",
            "back",
            "after",
            "use",
            "two",
            "how",
            "our",
            "work",
            "first",
            "well",
            "way",
            "even",
            "new",
            "want",
            "because",
            "any",
            "these",
            "give",
            "day",
            "most",
            "us" "is",
            "was",
            "are",
            "had",
            "word",
            "were",
            "said",
            "each",
            "many",
            "write" "long",
            "thing",
            "has",
            "more",
            "did",
            "sound",
            "number",
            "water",
            "call",
            "may" "down",
            "side",
            "been",
            "find",
            "part",
            "place",
            "made",
            "live",
            "where",
            "little" "round",
            "man",
            "came",
            "show",
            "every",
            "under",
            "name",
            "very",
            "through",
            "form" "sentence",
            "great",
            "help",
            "low",
            "line",
            "differ",
            "turn",
            "cause",
            "much",
            "mean" "before",
            "move",
            "right",
            "boy",
            "old",
            "too",
            "same",
            "tell",
            "does",
            "set" "three",
            "air",
            "play",
            "small",
            "end",
            "put",
            "home",
            "read",
            "hand",
            "port" "self",
            "earth",
            "father",
            "head",
            "stand",
            "own",
            "page",
            "should",
            "country",
            "found" "answer",
            "school",
            "grow",
            "study",
            "still",
            "learn",
            "plant",
            "cover",
            "food",
            "sun" "four",
            "thought",
            "let",
            "keep",
            "eye",
            "never",
            "last",
            "door",
            "between",
            "city" "tree",
            "cross",
            "since",
            "hard",
            "start",
            "might",
            "story",
            "saw",
            "far",
            "sea" "draw",
            "left",
            "late",
            "run",
            "don't",
            "while",
            "press",
            "close",
            "night",
            "real" "life",
            "few",
            "north",
            "open",
            "seem",
            "together",
            "next",
            "white",
            "children",
            "begin" "got",
            "walk",
            "example",
            "ease",
            "paper",
            "group",
            "always",
            "music",
            "those",
            "both" "mark",
            "often",
            "letter",
            "until",
            "mile",
            "river",
            "car",
            "feet",
            "care",
            "second" "book",
            "carry",
            "took",
            "science",
            "eat",
            "room",
            "friend",
            "began",
            "idea",
            "fish" "mountain",
            "stop",
            "once",
            "base",
            "hear",
            "horse",
            "cut",
            "sure",
            "watch",
            "color" "face",
            "wood",
            "main",
        }

        # Typing difficulty patterns
        self.difficult_patterns = [
            "th", "ch", "sh", "wh", "ph", "gh", "ck", "qu", "tion", "sion"
            "ture", "ible", "able", "ff", "ss", "tt", "pp", "cc", "gg", "dd"
            "bb", "mn", "gn", "ps", "pt", "rh", "kn", "wr", "mb", "ght"
            "eigh", "ough", "augh", "tch", "dge", "cei", "sch", "ious"

        ]

        # Decay settings
        self.decay_rate = 0.05  # 5% decay per day
        self.last_save_time = time.time()
    
    def load_memory(self):
        """Load word memory from disk."""
        try:
            with open(self.memory_file, "r", encoding="utf-8") as f:
                return json.load(f)
        except (FileNotFoundError, json.JSONDecodeError):
            return {}
    
    def save_memory(self):
        """Save word memory to disk."""
        # Apply time decay before saving
        self.apply_time_decay()
        
        with self.lock:  # Acquire lock for thread safety
            with open(self.memory_file, "w", encoding="utf-8") as f:
                json.dump(self.memory, f, indent=2)
        
            # Update last save time
            self.last_save_time = time.time()
    
    def apply_time_decay(self):
        """Apply time decay to confidence scores based on last access."""
        current_time = time.time()
        days_since_save = (current_time - self.last_save_time) / (60 * 60 * 24)
        
        # Only apply decay if at least a day has passed
        if days_since_save >= 1:
            with self.lock:  # Acquire lock for thread safety
                decay_factor = 1.0 - (self.decay_rate * days_since_save)
                decay_factor = max(0.5, decay_factor)  # Never decay below 50%
                
                for word in self.memory:
                    if 'confidence' in self.memory[word]:
                        self.memory[word]['confidence'] *= decay_factor
                        # Update last_seen timestamp to maintain recency info
                        if 'last_seen' in self.memory[word]:
                            self.memory[word]['last_seen'] = current_time
    
    def calculate_difficulty(self, word):
        """Calculate typing difficulty score for a word (0.0-1.0)."""
        if not word:
            return 0.0
            
        # Normalize to lowercase for consistency
        word = word.lower()
        
        # Base difficulty starts with length (longer = harder)
        length_factor = min(len(word) / 12, 1.0)  # Cap at 12 chars
        
        # Check for difficult letter combinations
        pattern_count = 0
        for pattern in self.difficult_patterns:
            if pattern in word:
                pattern_count += 1
        
        pattern_factor = min(pattern_count / 3, 1.0)  # Cap at 3 patterns
        
        # Check for repeated letters (easier to make mistakes)
        repeated = 0
        for i in range(len(word) - 1):
            if word[i] == word[i+1]:
                repeated += 1
        repeated_factor = min(repeated / 2, 1.0)  # Cap at 2 repeats
        
        # Calculate final difficulty score (0.0-1.0)
        difficulty = (length_factor * 0.4) + (pattern_factor * 0.4) + (repeated_factor * 0.2)
        return min(difficulty, 1.0)  # Ensure it doesn't exceed 1.0
    
    def update_word(self, word):
        """Record a word encounter, updating or creating its memory entry."""
        if not word or len(word) <= 1:
            return  # Skip very short words or empty strings
            
        with self.lock:  # Acquire lock for thread safety
            # Skip common words unless they're not in our memory yet
            if word.lower() in self.common_words and word in self.memory:
                if 'encounters' in self.memory[word]:
                    self.memory[word]['encounters'] += 1
                return
                
            # Initialize new word
            if word not in self.memory:
                difficulty = self.calculate_difficulty(word)
                self.memory[word] = {
                    'encounters': 1,
                    'difficulty': difficulty,
                    'confidence': max(0.2, 1.0 - difficulty),  # Start with inverse of difficulty, min 0.2
                    'last_seen': time.time(),
                    'first_seen': time.time()
                }
            else:
                # Update existing word
                self.memory[word]['encounters'] += 1
                self.memory[word]['last_seen'] = time.time()
                
                # Increase confidence with diminishing returns
                if self.memory[word]['encounters'] < 10:
                    confidence_gain = 0.1
                elif self.memory[word]['encounters'] < 20:
                    confidence_gain = 0.05
                else:
                    confidence_gain = 0.02
                    
                # Apply confidence increase, capped at 0.95 for non-common words
                new_confidence = self.memory[word]['confidence'] + confidence_gain
                self.memory[word]['confidence'] = min(0.95, new_confidence)
    
    def update_text(self, text):
        """Process a text sample, updating memory for each word."""
        if not text:
            return
            
        # Simple word tokenization (can be enhanced)
        words = text.split()
        for word in words:
            # Clean up the word
            clean_word = word.strip().strip('.,!?:;()[]{}"\'-')
            if clean_word:
                self.update_word(clean_word)
    
    def get_typing_params(self, word):
        """Get typing parameters for a word based on confidence score."""
        if not word or len(word) <= 1:
            return {
                'error_prob': 0.0,    # Probability of making a typo
                'pause_prob': 0.0,    # Probability of pausing before typing
                'pause_time': 0.0     # Pause duration if pausing (seconds)
            }
            
        with self.lock:  # Acquire lock for thread safety
            # For common words, we're always confident
            if word.lower() in self.common_words:
                return {
                    'error_prob': 0.005,  # Very low error chance on common words
                    'pause_prob': 0.0,    # No pausing on common words
                    'pause_time': 0.0
                }
                
            # For words not in memory, use difficulty calculation
            if word not in self.memory:
                difficulty = self.calculate_difficulty(word)
                return {
                    'error_prob': min(0.15, difficulty * 0.2),
                    'pause_prob': min(0.3, difficulty * 0.4),
                    'pause_time': min(0.5, difficulty * 0.6)
                }
                
            # Use stored confidence
            confidence = self.memory[word].get('confidence', 0.5)
            difficulty = self.memory[word].get('difficulty', 0.5)
            
            # Calculate error and pause probabilities inversely to confidence
            error_prob = max(0.005, (1.0 - confidence) * 0.15)  # More confident = fewer errors
            pause_prob = max(0.0, (1.0 - confidence) * 0.3)     # More confident = fewer pauses
            pause_time = max(0.1, (1.0 - confidence) * 0.6)     # Longer pauses when less confident
            
            return {
                'error_prob': error_prob,
                'pause_prob': pause_prob,
                'pause_time': pause_time
            }
    
    def get_words_by_confidence(self, threshold=0.5, limit=20):
        """Get words with confidence below a certain threshold."""
        result = []
        with self.lock:  # Acquire lock for thread safety
            for word, data in self.memory.items():
                if 'confidence' in data and data['confidence'] < threshold:
                    result.append((word, data['confidence'], data.get('encounters', 0)))
        
        # Sort by confidence (ascending)
        result.sort(key=lambda x: x[1])
        return result[:limit]
    
    def get_stats(self):
        """Get statistics about the word memory."""
        with self.lock:  # Acquire lock for thread safety
            total_words = len(self.memory)
            total_encounters = sum(data.get('encounters', 0) for data in self.memory.values())
            
            confidence_levels = {
                'low': 0,      # 0.0-0.3
                'medium': 0,   # 0.3-0.7
                'high': 0,     # 0.7-1.0
            }
            
            for data in self.memory.values():
                if 'confidence' in data:
                    if data['confidence'] < 0.3:
                        confidence_levels['low'] += 1
                    elif data['confidence'] < 0.7:
                        confidence_levels['medium'] += 1
                    else:
                        confidence_levels['high'] += 1
            
            return {
                'total_words': total_words,
                'total_encounters': total_encounters,
                'confidence_levels': confidence_levels
            }

keyboard_neighbors = {
    'a': ['s', 'q', 'z'],        'b': ['v', 'g', 'h', 'n'],
    'c': ['x', 'd', 'f', 'v'],   'd': ['s', 'e', 'r', 'f', 'c', 'x'],
    'e': ['w', 's', 'd', 'r'],   'f': ['d', 'r', 't', 'g', 'v', 'c'],
    'g': ['f', 't', 'y', 'h', 'b', 'v'], 'h': ['g', 'y', 'u', 'j', 'n', 'b'],
    'i': ['u', 'j', 'k', 'o'],   'j': ['h', 'u', 'i', 'k', 'm', 'n'],
    'k': ['j', 'i', 'o', 'l', ',', 'm'], 'l': ['k', 'o', 'p', ';', '.', ','],
    'm': ['n', 'j', 'k', '<'],   'n': ['b', 'h', 'j', 'm'],
    'o': ['i', 'k', 'l', 'p'],   'p': ['o', 'l', ';', '['],
    'q': ['a', 's', 'w'],        'r': ['e', 'd', 'f', 't'],
    's': ['a', 'w', 'e', 'd', 'x', 'z'], 't': ['r', 'f', 'g', 'y'],
    'u': ['y', 'h', 'j', 'i'],   'v': ['c', 'f', 'g', 'b'],
    'w': ['q', 'a', 's', 'e'],   'x': ['z', 's', 'd', 'c'],
    'y': ['t', 'g', 'h', 'u'],   'z': ['a', 's', 'x'],
    'A': ['S', 'Q', 'Z'],        'B': ['V', 'G', 'H', 'N'],
    'C': ['X', 'D', 'F', 'V'],   'D': ['S', 'E', 'R', 'F', 'C', 'X'],
    'E': ['W', 'S', 'D', 'R'],   'F': ['D', 'R', 'T', 'G', 'V', 'C'],
    'G': ['F', 'T', 'Y', 'H', 'B', 'V'], 'H': ['G', 'Y', 'U', 'J', 'N', 'B'],
    'I': ['U', 'J', 'K', 'O'],   'J': ['H', 'U', 'I', 'K', 'M', 'N'],
    'K': ['J', 'I', 'O', 'L', '<', 'M'], 'L': ['K', 'O', 'P', ':', '>', '<'],
    'M': ['N', 'J', 'K', '<'],   'N': ['B', 'H', 'J', 'M'],
    'O': ['I', 'K', 'L', 'P'],   'P': ['O', 'L', ':', '{'],
    'Q': ['A', 'S', 'W'],        'R': ['E', 'D', 'F', 'T'],
    'S': ['A', 'W', 'E', 'D', 'X', 'Z'], 'T': ['R', 'F', 'G', 'Y'],
    'U': ['Y', 'H', 'J', 'I'],   'V': ['C', 'F', 'G', 'B'],
    'W': ['Q', 'A', 'S', 'E'],   'X': ['Z', 'S', 'D', 'C'],
    'Y': ['T', 'G', 'H', 'U'],   'Z': ['A', 'S', 'X'],
    ';': ['l', 'p', '\'', ':'], ':': ['L', 'P', '"'],
    '\'': [';', ],               '"': [':'],
    ',': ['m', 'k', '.'],        '<': ['M', 'K', '>'],
    '.': ['l', ',', '/'],        '>': ['L', '<', '?'],
    '/': ['.', ';'],             '?': ['>', ':'],
    '-': ['0', '='],             '_': [')', '+'],
    '=': ['-', '['],             '+': ['_', '{'],
    '[': ['p', ']'],             '{': ['p', '}'],
    ']': ['[', '\\'],            '}': ['{', '|'],
    '\\': [']'],                 '|': ['}']
}

class StyleSheet:
    """Class to store application stylesheets"""
    
    MAIN = """
        QMainWindow, QDialog {
            background-color: #2e2e2e;
        }
        QPushButton {
            background-color: #0099FF;
            color: white;
            border: none;
            border-radius: 8px;
            padding: 12px 16px;
            font-weight: bold;
            font-size: 14px;
        }
        QPushButton:hover {
            background-color: #33BFFF;
        }
        QPushButton:pressed {
            background-color: #007ACC;
        }
        QPushButton#closeButton {
            background-color: #FF5252;
            color: white;
            font-weight: bold;
        }
        QPushButton#closeButton:hover {
            background-color: #FF7777;
        }
        QPushButton#closeButton:pressed {
            background-color: #CC4444;
        }
        QLabel {
            color: #e0e0e0;
            font-size: 14px;
        }
        QLabel#titleLabel {
            font-size: 20px;
            font-weight: bold;
            color: #0099FF;
        }
        QSlider {
            height: 24px;
        }
        QSlider::groove:vertical {
            background: #444444;
            width: 8px;
            border-radius: 4px;
        }
        QSlider::handle:vertical {
            background: #0099FF;
            height: 20px;
            width: 20px;
            margin: 0 -6px;
            border-radius: 10px;
        }
        QSlider::sub-page:vertical {
            background: #0099FF;
            border-radius: 4px;
        }
        QTextEdit {
            background-color: #2e2e2e;
            color: #e0e0e0;
            border: 1px solid #444444;
            border-radius: 4px;
            font-family: 'Consolas';
            font-size: 18px;
        }
        QProgressBar {
            background-color: #444444;
            border-radius: 8px;
            text-align: center;
            color: transparent;
        }
        QProgressBar::chunk {
            background-color: #0099FF;
            border-radius: 8px;
        }
        QCheckBox {
            color: #e0e0e0;
            font-size: 14px;
        }
        QCheckBox::indicator {
            width: 16px;
            height: 16px;
        }
    """
    # Cyberpunk (Dark City/Koi)
    CYBERPUNK = """
        QMainWindow, QDialog {
            background-color: #10101a;
        }
        QPushButton {
            background-color: #1a1a2e;
            color: #f8f8ff;
            border: none;
            border-radius: 8px;
            padding: 12px 16px;
            font-weight: bold;
            font-size: 14px;
        }
        QPushButton:hover {
            background-color: #23234d;
        }
        QPushButton:pressed {
            background-color: #0f3460;
        }
        QPushButton#closeButton {
            background-color: #ff2e63;
            color: #fff;
            font-weight: bold;
        }
        QPushButton#closeButton:hover {
            background-color: #ff5e8e;
        }
        QPushButton#closeButton:pressed {
            background-color: #b2224b;
        }
        QPushButton#templateButton {
            background-color: #08d9d6;
            color: #1a1a2e;
            font-size: 12px;
            padding: 8px 10px;
        }
        QPushButton#templateButton:hover {
            background-color: #20e7e4;
        }
        QLabel {
            color: #f8f8ff;
            font-size: 14px;
        }
        QLabel#titleLabel {
            font-size: 20px;
            font-weight: bold;
            color: #08d9d6;
        }
        QLabel#statusLabel {
            color: #08d9d6;
            font-size: 12px;
            border: 1px solid #23234d;
            border-radius: 4px;
            padding: 4px;
            background-color: #1a1a2e;
        }
        QSlider {
            height: 24px;
        }
        QSlider::groove:horizontal, QSlider::groove:vertical {
            background: #23234d;
            border-radius: 4px;
        }
        QSlider::handle:horizontal, QSlider::handle:vertical {
            background: #08d9d6;
            border-radius: 10px;
        }
        QSlider::sub-page:horizontal, QSlider::sub-page:vertical {
            background: #ff2e63;
            border-radius: 4px;
        }
        QTextEdit {
            background-color: #181828;
            color: #f8f8ff;
            border: 1px solid #23234d;
            border-radius: 4px;
            font-family: 'Consolas';
            font-size: 18px;
        }
        QProgressBar {
            background-color: #23234d;
            border-radius: 8px;
            text-align: center;
            color: transparent;
        }
        QProgressBar::chunk {
            background-color: #08d9d6;
            border-radius: 8px;
        }
        QCheckBox {
            color: #f8f8ff;
            font-size: 14px;
        }
        QCheckBox::indicator {
            width: 16px;
            height: 16px;
        }
        QToolTip {
            background-color: #1a1a2e;
            color: #f8f8ff;
            border: 1px solid #08d9d6;
            padding: 5px;
        }
        QScrollBar:vertical {
            border: none;
            background: #23234d;
            width: 10px;
            margin: 0;
        }
        QScrollBar::handle:vertical {
            background: #08d9d6;
            min-height: 20px;
            border-radius: 5px;
        }
        QComboBox {
            background-color: #1a1a2e;
            color: #f8f8ff;
            border: 1px solid #23234d;
            border-radius: 4px;
            padding: 4px;
        }
        QComboBox::drop-down {
            border: none;
        }
        QComboBox QAbstractItemView {
            background-color: #1a1a2e;
            color: #f8f8ff;
            selection-background-color: #08d9d6;
            selection-color: #1a1a2e;
        }
    """
    # Pink City (Light Mode)
    PINK_CITY = """
        QMainWindow, QDialog {
            background-color: #fff0f6;
        }
        QPushButton {
            background-color: #ffb6d5;
            color: #7a316f;
            border: none;
            border-radius: 8px;
            padding: 12px 16px;
            font-weight: bold;
            font-size: 14px;
        }
        QPushButton:hover {
            background-color: #ffd6e0;
        }
        QPushButton:pressed {
            background-color: #ff6f91;
        }
        QPushButton#closeButton {
            background-color: #ff6f91;
            color: #fff;
            font-weight: bold;
        }
        QPushButton#closeButton:hover {
            background-color: #ffb6d5;
        }
        QPushButton#closeButton:pressed {
            background-color: #d72660;
        }
        QPushButton#templateButton {
            background-color: #d72660;
            color: #fff0f6;
            font-size: 12px;
            padding: 8px 10px;
        }
        QPushButton#templateButton:hover {
            background-color: #ff6f91;
        }
        QLabel {
            color: #7a316f;
            font-size: 14px;
        }
        QLabel#titleLabel {
            font-size: 20px;
            font-weight: bold;
            color: #d72660;
        }
        QLabel#statusLabel {
            color: #7a316f;
            font-size: 12px;
            border: 1px solid #ffd6e0;
            border-radius: 4px;
            padding: 4px;
            background-color: #fff6fa;
        }
        QSlider {
            height: 24px;
        }
        QSlider::groove:horizontal, QSlider::groove:vertical {
            background: #ffd6e0;
            border-radius: 4px;
        }
        QSlider::handle:horizontal, QSlider::handle:vertical {
            background: #d72660;
            border-radius: 10px;
        }
        QSlider::sub-page:horizontal, QSlider::sub-page:vertical {
            background: #ffb6d5;
            border-radius: 4px;
        }
        QTextEdit {
            background-color: #fff0f6;
            color: #7a316f;
            border: 1px solid #ffd6e0;
            border-radius: 4px;
            font-family: 'Consolas';
            font-size: 18px;
        }
        QProgressBar {
            background-color: #ffd6e0;
            border-radius: 8px;
            text-align: center;
            color: transparent;
        }
        QProgressBar::chunk {
            background-color: #d72660;
            border-radius: 8px;
        }
        QCheckBox {
            color: #7a316f;
            font-size: 14px;
        }
        QCheckBox::indicator {
            width: 16px;
            height: 16px;
        }
        QToolTip {
            background-color: #fff6fa;
            color: #7a316f;
            border: 1px solid #d72660;
            padding: 5px;
        }
        QScrollBar:vertical {
            border: none;
            background: #ffd6e0;
            width: 10px;
            margin: 0;
        }
        QScrollBar::handle:vertical {
            background: #d72660;
            min-height: 20px;
            border-radius: 5px;
        }
        QComboBox {
            background-color: #fff6fa;
            color: #7a316f;
            border: 1px solid #ffd6e0;
            border-radius: 4px;
            padding: 4px;
        }
        QComboBox::drop-down {
            border: none;
        }
        QComboBox QAbstractItemView {
            background-color: #fff6fa;
            color: #7a316f;
            selection-background-color: #d72660;
            selection-color: #fff0f6;
        }
    """

class AutoCorrectTextEdit(QTextEdit):
    """QTextEdit with autocorrect functionality"""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.autocorrect_enabled = True
        self.textChanged.connect(self.check_for_correction)
        # Track sentence endings for auto-capitalization
        self.last_char_was_sentence_end = True  # Start of document is sentence end
        
    def toggle_autocorrect(self, enabled):
        """Enable or disable autocorrect"""
        self.autocorrect_enabled = enabled
    
    def keyPressEvent(self, event):
        """Override to track sentence endings and potentially auto-capitalize"""
        # Check for auto-capitalization
        if self.autocorrect_enabled and event.text() == " ":
            cursor = self.textCursor()
            pos = cursor.position()
            doc = self.document()
            text = doc.toPlainText()
            
            # Auto-capitalize standalone i to I
            if pos >= 2 and text[pos-2:pos] == "i ":
                # Check if i is standalone (surrounded by spaces or at start)
                if pos == 2 or text[pos-3] in " \n\t":
                    cursor.setPosition(pos-2)
                    cursor.movePosition(QTextCursor.Right, QTextCursor.KeepAnchor, 1)
                    cursor.insertText("I")
                    # No need to reset cursor, it maintains position after edit
                    
        # Call base method to handle the key normally
        super().keyPressEvent(event)
        
        # After handling key, update sentence tracking
        if event.text() in ".!?":
            self.last_char_was_sentence_end = True
        elif self.last_char_was_sentence_end and event.text().strip():
            # Auto-capitalize first letter of sentences
            # First letter after sentence end that isn't whitespace
            if event.text().islower():
                cursor = self.textCursor()
                cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, 1)
                cursor.insertText(event.text().upper())
            self.last_char_was_sentence_end = False
    
    def check_for_correction(self):
        if not self.autocorrect_enabled:
            return

        cursor = self.textCursor()
        # Use document().toPlainText() for a stable view of text, cursor.position() for current pos
        current_doc_text = self.document().toPlainText() 
        cursor_pos = cursor.position()

        # Add safety check for empty document or cursor at beginning
        if cursor_pos <= 0 or not current_doc_text or cursor_pos > len(current_doc_text):
            return

        # The character just typed is at cursor_pos - 1
        last_char_typed = current_doc_text[cursor_pos - 1]

        # Define word delimiters that trigger the autocorrection check
        delimiters = {" ", ".", ",", "!", "?", ";", "\n", "\t"}

        if last_char_typed in delimiters:
            # Find the start of the word that precedes the delimiter
            # Search backwards from the character *before* the delimiter (cursor_pos - 2)
            search_end_idx = cursor_pos - 2
            
            # Another safety check
            if search_end_idx < 0:
                return
                
            start_of_word_idx = -1

            for i in range(search_end_idx, -1, -1):
                if current_doc_text[i] in delimiters:
                    start_of_word_idx = i + 1 # Word starts after this delimiter
                    break
            else: # Loop finished without break, means no delimiter found before this word
                if search_end_idx >=0 : # Only if there were characters to form a word
                    start_of_word_idx = 0 # Word starts at the beginning of the text
            
            # Ensure a valid word was found (start_of_word_idx is valid and before or at search_end_idx)
            if start_of_word_idx != -1 and start_of_word_idx <= search_end_idx:
                # Extract the original word as it appears in the text_edit (end index for slice is exclusive)
                original_word_in_doc = current_doc_text[start_of_word_idx : cursor_pos -1]

                # Prepare word for dictionary lookup: lowercase, strip surrounding whitespace, and specific trailing punctuation
                word_for_dict_lookup_base = original_word_in_doc.strip().lower()
                
                punctuation_to_strip_for_dict = ".,;:!?\"'()[]{}"
                cleaned_word_for_dict = word_for_dict_lookup_base
                # Iteratively remove trailing punctuation that's in our defined set
                while cleaned_word_for_dict and cleaned_word_for_dict[-1] in punctuation_to_strip_for_dict:
                    cleaned_word_for_dict = cleaned_word_for_dict[:-1]

                if cleaned_word_for_dict and cleaned_word_for_dict in AUTOCORRECT_DICT:
                    correction_template = AUTOCORRECT_DICT[cleaned_word_for_dict]
                    
                    final_correction = correction_template
                    # Try to preserve original capitalization if it was just the first letter
                    original_stripped_word = original_word_in_doc.strip()
                    if original_stripped_word and original_stripped_word[0].isupper() and len(original_stripped_word) == len(cleaned_word_for_dict):
                        if cleaned_word_for_dict == original_stripped_word.lower(): # Check if it's the same word, just different case
                           final_correction = correction_template[0].upper() + correction_template[1:]
                    
                    trailing_punctuation = ""
                    # Preserve trailing punctuation from the original word if it was stripped for dict lookup
                    if len(original_stripped_word) > len(cleaned_word_for_dict):
                         potential_punct = original_stripped_word[len(cleaned_word_for_dict):]
                         is_all_known_punct = True
                         for char_p in potential_punct:
                             if char_p not in punctuation_to_strip_for_dict:
                                 is_all_known_punct = False
                                 break
                         if is_all_known_punct:
                             trailing_punctuation = potential_punct

                    # Only perform replacement if the corrected version is actually different
                    if original_word_in_doc.strip() != final_correction + trailing_punctuation:
                        self.blockSignals(True) # Prevent textChanged recursion
                        
                        mod_cursor = self.textCursor() # Use a fresh cursor for modification
                        mod_cursor.setPosition(start_of_word_idx) # Go to the start of the word to replace
                        # Select the original word slice as identified (length of original_word_in_doc)
                        mod_cursor.movePosition(QTextCursor.Right, QTextCursor.KeepAnchor, len(original_word_in_doc))
                        
                        mod_cursor.insertText(final_correction + trailing_punctuation)
                        
                        self.blockSignals(False) # Re-enable signals
                        return # Correction made, exit

class DirectWindowTyper:
    """Types into a window with focus control options"""
    
    def __init__(self, hwnd, background_mode=False, notepad_mode=False):
        self.hwnd = hwnd
        self.background_mode = background_mode
        self.notepad_mode = notepad_mode
        # Get window title for better identification
        title_len = user32.GetWindowTextLengthW(hwnd)
        buff = ctypes.create_unicode_buffer(title_len + 1)
        user32.GetWindowTextW(hwnd, buff, title_len + 1)
        self.window_title = buff.value
        # Track success/failure of methods
        self.last_method_used = None
        self.method_success_count = {
            "direct_send": 0,
            "direct_post": 0,
            "notepad_em": 0,
            "pyautogui": 0
        }
    
    def normalize_special_char(self, char):
        """Replace special characters with standard equivalents"""
        return SPECIAL_CHAR_REPLACEMENTS.get(char, char)
    
    def ensure_window_focus(self):
        """Make sure the target window has focus if not in background mode"""
        if not user32.IsWindow(self.hwnd):
            return False
            
        # In background mode, we don't need focus, just check window is valid
        if self.background_mode:
            return True
            
        # If already has focus, we're good
        if user32.GetForegroundWindow() == self.hwnd:
            return True
            
        # Try to focus the window - multiple attempts
        for i in range(3):
            # If window is minimized, restore it
            if user32.IsIconic(self.hwnd):
                user32.ShowWindow(self.hwnd, 9)  # SW_RESTORE = 9
                time.sleep(0.1)
                
            # Activate the window
            if user32.SetForegroundWindow(self.hwnd):
                time.sleep(0.1)  # Wait a bit for focus
                if user32.GetForegroundWindow() == self.hwnd:
                    return True
            
            # If not successful, wait a bit longer and try again
            time.sleep(0.2)
        
        # Could not set focus after multiple attempts
        return False
    
    def try_direct_message(self, char, method="send"):
        """Try to type using direct Windows messaging"""
        try:
            # For Notepad mode, use the EM_REPLACESEL message directly
            if self.notepad_mode and char:
                EM_REPLACESEL = 0x00C2
                char_buffer = ctypes.create_unicode_buffer(char)
                if method == "send":
                    result = user32.SendMessageW(self.hwnd, EM_REPLACESEL, 1, ctypes.byref(char_buffer))
                else:
                    result = user32.PostMessageW(self.hwnd, EM_REPLACESEL, 1, ctypes.byref(char_buffer))
                if result:
                    self.method_success_count["notepad_em"] += 1
                    self.last_method_used = "notepad_em"
                    return True
                    
            # For function keys or special keys
            if char == '\n':
                # Send Enter key
                if method == "send":
                    user32.SendMessageW(self.hwnd, WM_KEYDOWN, VK_RETURN, 0)
                    user32.SendMessageW(self.hwnd, WM_KEYUP, VK_RETURN, 0)
                else:
                    user32.PostMessageW(self.hwnd, WM_KEYDOWN, VK_RETURN, 0)
                    user32.PostMessageW(self.hwnd, WM_KEYUP, VK_RETURN, 0)
            elif char == '\t':
                # Send Tab key
                if method == "send":
                    user32.SendMessageW(self.hwnd, WM_KEYDOWN, VK_TAB, 0)
                    user32.SendMessageW(self.hwnd, WM_KEYUP, VK_TAB, 0)
                else:
                    user32.PostMessageW(self.hwnd, WM_KEYDOWN, VK_TAB, 0)
                    user32.PostMessageW(self.hwnd, WM_KEYUP, VK_TAB, 0)
            elif char == '\b':
                # Send Backspace key
                if method == "send":
                    user32.SendMessageW(self.hwnd, WM_KEYDOWN, VK_BACK, 0)
                    user32.SendMessageW(self.hwnd, WM_KEYUP, VK_BACK, 0)
                else:
                    user32.PostMessageW(self.hwnd, WM_KEYDOWN, VK_BACK, 0)
                    user32.PostMessageW(self.hwnd, WM_KEYUP, VK_BACK, 0)
            elif not char:
                # Empty char is just for testing if the window accepts messages
                return True
            else:
                # Send regular character
                char_code = ord(char)
                if method == "send":
                    result = user32.SendMessageW(self.hwnd, WM_CHAR, char_code, 0)
                else:
                    result = user32.PostMessageW(self.hwnd, WM_CHAR, char_code, 0)
                
                if not result:
                    # If we're dealing with Notepad, try another approach
                    if "notepad" in self.window_title.lower() or self.notepad_mode:
                        # Notepad specific approach - EM_REPLACESEL message
                        EM_REPLACESEL = 0x00C2
                        char_buffer = ctypes.create_unicode_buffer(char)
                        if method == "send":
                            result = user32.SendMessageW(self.hwnd, EM_REPLACESEL, 1, ctypes.byref(char_buffer))
                        else:
                            result = user32.PostMessageW(self.hwnd, EM_REPLACESEL, 1, ctypes.byref(char_buffer))
                        if result:
                            self.method_success_count["notepad_em"] += 1
                            self.last_method_used = "notepad_em"
                            return True
                    return False
            return True
        except Exception as e:
            print(f"Exception in try_direct_message: {e}")
            return False
    
    def type_char(self, char):
        """Type a single character, using best available method"""
        if not user32.IsWindow(self.hwnd):
            return False
            
        # Normalize special characters that may not be supported by all applications
        normalized_char = self.normalize_special_char(char)
        
        # If the character was normalized to multiple characters, handle as a string
        if len(normalized_char) > 1 and normalized_char != char:
            return self.type_string(normalized_char, 0.01)  # Small delay between chars
            
        # If in background mode, try direct message first
        if self.background_mode:
            # Try SendMessage first
            if self.try_direct_message(normalized_char, "send"):
                self.method_success_count["direct_send"] += 1
                self.last_method_used = "direct_send"
                return True
                
            # Try PostMessage next
            if self.try_direct_message(normalized_char, "post"):
                self.method_success_count["direct_post"] += 1
                self.last_method_used = "direct_post"
                return True
                
            # If both direct methods fail, fall back to pyautogui with focus
            if self.ensure_window_focus():
                if normalized_char == '\b':  # backspace
                    pyautogui.press('backspace')
                else:
                    pyautogui.typewrite(normalized_char)
                self.method_success_count["pyautogui"] += 1
                self.last_method_used = "pyautogui"
                return True
                
            return False
        else:
            # Regular typing with pyautogui - requires focus
            if not self.ensure_window_focus():
                # Failed to give focus to target window
                return False
            
            if normalized_char == '\b':  # backspace
                pyautogui.press('backspace')
            else:
                pyautogui.typewrite(normalized_char)
            
            self.method_success_count["pyautogui"] += 1
            self.last_method_used = "pyautogui"
            return True
        
    def get_diagnostic_info(self):
        """Return diagnostic information about which methods worked"""
        return f"SendMessage: {self.method_success_count['direct_send']}, " \
               f"PostMessage: {self.method_success_count['direct_post']}, " \
               f"NotepadEM: {self.method_success_count['notepad_em']}, " \
               f"PyAutoGUI: {self.method_success_count['pyautogui']}, " \
               f"Last method: {self.last_method_used}"
    
    def type_string(self, text, delay=0.01):
        """Type a string with optional delay between characters"""
        if not text or not user32.IsWindow(self.hwnd):
            return False
            
        success = True
        for char in text:
            if not self.type_char(char):
                success = False
                
            if delay > 0:
                time.sleep(delay)
                
        return success
    
    def paste_text(self, text):
        """Set clipboard and paste text"""
        if not text or not user32.IsWindow(self.hwnd):
            return False
            
        # Normalize special characters in text
        normalized_text = ""
        for char in text:
            normalized_text += self.normalize_special_char(char)
        
        # Save original clipboard content
        original_clipboard = pyperclip.paste()
        
        try:
            # Set clipboard to desired text
            pyperclip.copy(normalized_text)
            
            if self.background_mode:
                # Try different approaches to paste
                # First approach: Direct Windows messages
                success = False
                
                # Try SendMessage for Ctrl+V
                try:
                    user32.SendMessageW(self.hwnd, WM_KEYDOWN, VK_CONTROL, 0)
                    user32.SendMessageW(self.hwnd, WM_KEYDOWN, ord('V'), 0)
                    user32.SendMessageW(self.hwnd, WM_KEYUP, ord('V'), 0)
                    user32.SendMessageW(self.hwnd, WM_KEYUP, VK_CONTROL, 0)
                    success = True
                    self.method_success_count["direct_send"] += 1
                except:
                    success = False
                
                # If that fails, try PostMessage for Ctrl+V
                if not success:
                    try:
                        user32.PostMessageW(self.hwnd, WM_KEYDOWN, VK_CONTROL, 0)
                        user32.PostMessageW(self.hwnd, WM_KEYDOWN, ord('V'), 0)
                        user32.PostMessageW(self.hwnd, WM_KEYUP, ord('V'), 0)
                        user32.PostMessageW(self.hwnd, WM_KEYUP, VK_CONTROL, 0)
                        success = True
                        self.method_success_count["direct_post"] += 1
                    except:
                        success = False
                
                # If all else fails, fall back to pyautogui
                if not success and self.ensure_window_focus():
                    pyautogui.hotkey('ctrl', 'v')
                    success = True
                    self.method_success_count["pyautogui"] += 1
            else:
                # Ensure window has focus
                if not self.ensure_window_focus():
                    return False
                    
                # Paste with keyboard shortcut
                pyautogui.hotkey('ctrl', 'v')
                success = True
                self.method_success_count["pyautogui"] += 1
                
            time.sleep(0.05)  # Brief pause to ensure paste completes
            
            return success
        finally:
            # Restore original clipboard
            pyperclip.copy(original_clipboard)
    
    def type_string_failsafe(self, text, delay=0.01):
        """Alternative typing method that tries individual characters and checks focus after each one"""
        if not text or not user32.IsWindow(self.hwnd):
            return False
            
        success = True
        for char in text:
            # Ensure focus for each character if not in background mode
            if not self.background_mode and not self.ensure_window_focus():
                return False
                
            # Type the character with all possible methods until one works
            if not self.type_char(char):
                success = False
                
            # Delay between characters
            if delay > 0:
                time.sleep(delay)

        return success

class TypingThread(QThread):
    progress = pyqtSignal(int)
    finished = pyqtSignal()
    error = pyqtSignal(str)
    word_learned = pyqtSignal(str, float)  # Signal to emit when confidence in a word changes
    
    def __init__(self, text, delay, error_rate, punc_pause_prob, space_pause_prob, thinking_pause_prob, 
                 background_mode, notepad_mode=False, word_memory=None):
        super().__init__()
        self.text = text
        self.delay = delay
        self.error_rate = error_rate
        self.punc_pause_prob = punc_pause_prob
        self.space_pause_prob = space_pause_prob
        self.thinking_pause_prob = thinking_pause_prob
        self.background_mode = background_mode
        self.notepad_mode = notepad_mode
        self.running = True
        self.target_window = None
        self.word_memory = word_memory  # Instance of WordMemory class
        self.silent_mode = False  # For multi-bot operation without UI signals
        
        # Personality-specific attributes
        self.correction_style = "immediate"  # immediate, delayed, or none
        self.emoji_handling = "direct"  # direct, pause, or confused
        self.is_code_aware = False  # Better code indentation handling
        self.uses_rhythm_variation = False  # Varies typing rhythm naturally
        self.uses_double_space = False  # Double spaces after periods
        self.common_misspellings = []  # List of (correct, misspelled) pairs
        
        # Update word memory with the text to be typed (gives bot a "preview")
        if self.word_memory:
            self.word_memory.update_text(text)
    
    def set_target_window(self, hwnd):
        """Pre-set the target window instead of asking for click"""
        self.target_window = hwnd
    
    def set_silent_mode(self, silent=True):
        """Disables UI signals/prompts for headless operation"""
        self.silent_mode = silent
    
    def type_for_timeslice(self, seconds):
        """Type for a specific amount of time then yield control.
        Used for round-robin focus management in multi-bot scenarios."""
        # Store current position to resume later
        if not hasattr(self, 'current_position'):
            self.current_position = 0
        
        if not hasattr(self, 'typer') or not self.typer:
            # Create typer if not already created
            if hasattr(self, 'target_window') and self.target_window:
                self.typer = DirectWindowTyper(self.target_window, self.background_mode, self.notepad_mode)
            else:
                return  # Can't type without a target window
        
        start_time = time.time()
        chars_typed = 0
        max_chars_per_slice = 30  # Don't type too many characters at once
        
        # Type until time is up or max chars reached
        while (time.time() - start_time < seconds and 
               chars_typed < max_chars_per_slice and 
               self.current_position < len(self.text) and 
               self.running):
            
            # Get the current character
            ch = self.text[self.current_position]
            
            # Use the same typing logic as in run() but simplified
            try:
                # Get current word for context
                current_word = self.extract_current_word(self.text, self.current_position)
                if current_word:
                    word_typing_params = self.get_word_specific_typing_params(current_word, self.error_rate)
                else:
                    word_typing_params = {'error_prob': self.error_rate, 'pause_prob': 0.0, 'pause_time': 0.0}
                
                # Handle simple newline case
                if ch == '\n':
                    self.typer.type_char('\n')
                    time.sleep(self.delay)
                    
                    # Skip ahead to next character
                    self.current_position += 1
                    chars_typed += 1
                    continue
                
                                    # Type the character with potential errors, influenced by personality
                make_error = False
                
                # Apply personality-specific common misspellings
                if self.common_misspellings and ch.isalnum():
                    current_word = self.extract_current_word(self.text, self.current_position)
                    if current_word:
                        # Check if this word is in our common misspellings
                        for correct, misspelled in self.common_misspellings:
                            if current_word.lower() == correct.lower():
                                # Higher chance of making an error
                                if random.random() < word_typing_params.get('error_prob', self.error_rate) * 2:
                                    make_error = True
                                    break
                
                # Regular error probability if not a common misspelling
                if not make_error and ch.isalnum() and random.random() < word_typing_params.get('error_prob', self.error_rate):
                    make_error = True
                
                if make_error:
                    # Simulate typo
                    if (nb := keyboard_neighbors.get(ch, [])):
                        typo = random.choice(nb)
                        self.typer.type_char(typo)
                        time.sleep(self.delay)
                        
                        # Apply correction style from personality
                        if self.correction_style == "immediate":
                            # Correct mistake immediately
                            self.typer.type_char('\b')  # Backspace
                            time.sleep(self.delay)
                        elif self.correction_style == "delayed":
                            # Sometimes notice mistakes later (continues typing then goes back)
                            if random.random() < 0.7:  # 70% chance to correct
                                self.typer.type_char('\b')  # Backspace
                                time.sleep(self.delay)
                            else:
                                # Will be handled as missed correction (not corrected)
                                pass
                        elif self.correction_style == "none":
                            # Don't correct errors (simulates very casual typing)
                            pass
                        else:
                            # Default to immediate correction
                            self.typer.type_char('\b')  # Backspace
                            time.sleep(self.delay)
                
                # Type the actual character
                if emoji.is_emoji(ch):
                    self.typer.paste_text(ch)
                else:
                    self.typer.type_char(ch)
                
                time.sleep(self.delay)
                
                # Advance position
                self.current_position += 1
                chars_typed += 1
                
            except Exception as e:
                print(f"Error in type_for_timeslice: {e}")
                self.current_position += 1  # Skip problematic character
        
        # Return value indicates if there's more to type
        return self.current_position < len(self.text)
    
    def extract_current_word(self, text, pos):
        """Extract the current word at position in text."""
        if not text or pos >= len(text):
            return ""
        
        # Find word boundaries (space, punctuation, etc.)
        word_start = pos
        while word_start > 0 and text[word_start-1].isalnum():
            word_start -= 1
        
        word_end = pos
        while word_end < len(text) and text[word_end].isalnum():
            word_end += 1
        
        return text[word_start:word_end]
    
    def get_word_specific_typing_params(self, word, base_error_rate):
        """Get word-specific typing parameters based on confidence."""
        if not word or not self.word_memory:
            return {
                'error_prob': base_error_rate,
                'pause_prob': 0.0,
                'pause_time': 0.0
            }
        
        # Get parameters from word memory
        params = self.word_memory.get_typing_params(word)
        
        # Blend with base error rate (adjust weight based on what feels most natural)
        # Here we're doing 60% word-specific, 40% global error rate
        params['error_prob'] = (params['error_prob'] * 0.6) + (base_error_rate * 0.4)
        
        return params
    
    def run(self):
        try:
            # Reset current position to start from the beginning
            self.current_position = 0
            
            if not self.silent_mode:
                self.error.emit("👆 Click in the target window now...")
                time.sleep(1)  # Brief pause
                self.error.emit("⌨️ Get ready to type in 1 second...")
                time.sleep(1)  # Second pause before starting
            
            # If target window is not set, get the active window handle
            if not self.target_window:
                self.target_window = user32.GetForegroundWindow()
                
            if not user32.IsWindow(self.target_window):
                if not self.silent_mode:
                    self.error.emit("❌ Invalid target window selected. Please try again.")
                self.finished.emit()
                return
                
            # Get window title for better identification
            title_len = user32.GetWindowTextLengthW(self.target_window)
            buff = ctypes.create_unicode_buffer(title_len + 1)
            user32.GetWindowTextW(self.target_window, buff, title_len + 1)
            self.target_title = buff.value
            
            # Create diagnostic label for background mode
            bg_status = "enabled" if self.background_mode else "disabled"
            notepad_status = "enabled" if self.notepad_mode else "disabled"
            if not self.silent_mode:
                self.error.emit(f"✅ Typing into: {self.target_title} (Background: {bg_status}, Notepad: {notepad_status})")
                self.error.emit("ℹ️ Special character normalization active (curly quotes → straight quotes, em dashes → hyphens, etc.)")
                self.error.emit("🧠 Word-specific confidence scoring active (pauses and error rates adapt to word familiarity)")
            
            # Create direct typer
            self.typer = DirectWindowTyper(self.target_window, self.background_mode, self.notepad_mode)
            
            # First ensure window has focus before we start
            if not self.typer.ensure_window_focus():
                if not self.silent_mode:
                    self.error.emit(f"Could not focus target window: {self.target_title}")
                self.finished.emit()
                return
                
            # Test typing with each method to identify what works with this window type
            if not self.silent_mode:
                self.error.emit("🧪 Testing typing methods...")
            
            # Try the direct send method
            direct_send_works = self.typer.try_direct_message("", "send")  # Try empty char to test without typing
            
            # Try the direct post method
            direct_post_works = self.typer.try_direct_message("", "post")  # Try empty char to test without typing
            
            # PyAutoGUI always works when window has focus
            pyautogui_works = True
            
            # Log the results
            if not self.silent_mode:
                self.error.emit(f"Compatible methods: DirectSend={direct_send_works}, DirectPost={direct_post_works}, PyAutoGUI={pyautogui_works}")
            
            # If we're in background mode but direct messaging won't work, warn the user
            if self.background_mode and not (direct_send_works or direct_post_works) and not self.silent_mode:
                self.error.emit("⚠️ Background mode may not work with this window type. Falling back to foreground typing.")
            
            total = len(self.text)
            current_line_indent = ''
            current_word = ""
            word_typing_params = {}
            
            # Add rate limiting
            char_count = 0
            last_reset = time.time()
            last_focus_check = time.time()
            words_typed = set()  # Track words we've fully typed
            
            # If we're handling typing in time slices through the focus manager, we can skip the main typing loop
            if hasattr(self, 'current_position') and self.current_position > 0:
                # We're being managed by the focus manager, so just finish up
                self.progress.emit(100)
                self.finished.emit()
                return
            
            while self.current_position < total and self.running:
                try:
                    # Rate limiting - no more than 30 chars per second regardless of delay setting
                    char_count += 1
                    if (char_count > 30):
                        now = time.time()
                        if now - last_reset < 1.0:
                            time.sleep(1.0 - (now - last_reset))
                        char_count = 0
                        last_reset = time.time()
                        
                    # Check window is still valid periodically
                    if not user32.IsWindow(self.target_window):
                        if not self.silent_mode:
                            self.error.emit("Target window closed or became invalid during typing.")
                        break # Exit the loop
                    
                    # Check focus every 1 second to make sure we haven't lost it
                    now = time.time()
                    if now - last_focus_check > 1.0:
                        if not self.typer.ensure_window_focus():
                            if not self.silent_mode:
                                self.error.emit("Lost focus on target window. Trying to refocus...")
                            if not self.typer.ensure_window_focus():  # Try one more time
                                if not self.silent_mode:
                                    self.error.emit("Could not refocus target window. Aborting.")
                                break
                        last_focus_check = now

                    ch = self.text[self.current_position]
                    
                    # Update current word and word-specific typing parameters when on a word boundary
                    if self.current_position == 0 or not self.text[self.current_position-1].isalnum():
                        current_word = self.extract_current_word(self.text, self.current_position)
                        if current_word:
                            word_typing_params = self.get_word_specific_typing_params(current_word, self.error_rate)
                        else:
                            word_typing_params = {'error_prob': self.error_rate, 'pause_prob': 0.0, 'pause_time': 0.0}
                    
                    # autotab logic
                    if ch == '\n':
                        prev_newline = self.text.rfind('\n', 0, self.current_position)
                        if prev_newline == -1:
                            prev_line = self.text[:self.current_position]
                        else:
                            prev_line = self.text[prev_newline+1:self.current_position]
                        
                        leading_ws = ''
                        for c in prev_line:
                            if c in (' ', '\t'):
                                leading_ws += c
                            else:
                                break
                                
                        current_line_indent = leading_ws
                        if prev_line.rstrip().endswith(':'):
                            current_line_indent += '    '
                        
                        # Type newline
                        if not self.typer.type_char('\n'):
                            if not self.silent_mode:
                                self.error.emit("Failed to type newline. Window may have lost focus.")
                            continue
                        time.sleep(self.delay)
                        
                        # Add indentation if needed
                        if current_line_indent:
                            success = self.typer.type_string_failsafe(current_line_indent, self.delay)
                            if not success:
                                if not self.silent_mode:
                                    self.error.emit("Warning: Failed to type indentation. Trying alternative method...")
                                # Try character by character as fallback
                                for indent_char in current_line_indent:
                                    if not self.typer.type_char(indent_char):
                                        if not self.silent_mode:
                                            self.error.emit("Failed to type indentation character.")
                                    time.sleep(self.delay)
                        
                        self.current_position += 1
                        self.progress.emit(int((self.current_position / total) * 100))
                        continue

                    # Word-specific typo probability instead of global error rate
                    # Use word_typing_params['error_prob'] 
                    make_typo = False
                    if ch.isalnum() and random.random() < word_typing_params.get('error_prob', self.error_rate):
                        if (nb := keyboard_neighbors.get(ch, [])):
                            make_typo = True
                            typo = random.choice(nb)
                            if not self.typer.type_char(typo):
                                if not self.silent_mode:
                                    self.error.emit("Failed to type typo character. Checking window focus...")
                                if not self.typer.ensure_window_focus():
                                    if not self.silent_mode:
                                        self.error.emit("Lost focus and could not refocus. Aborting.")
                                    break
                            time.sleep(self.delay)
                            if not self.typer.type_char('\b'):  # backspace
                                if not self.silent_mode:
                                    self.error.emit("Failed to type backspace. Checking window focus...")
                                if not self.typer.ensure_window_focus():
                                    if not self.silent_mode:
                                        self.error.emit("Lost focus and could not refocus. Aborting.")
                                    break
                            time.sleep(self.delay)
                    
                    # Word-specific pausing before typing a difficult word
                    if current_word and current_word not in words_typed and random.random() < word_typing_params.get('pause_prob', 0.0):
                        if not self.silent_mode:
                            self.error.emit(f"Pausing at '{current_word}': {word_typing_params.get('pause_time', 0.2):.1f}s")
                        time.sleep(word_typing_params.get('pause_time', 0.2))
                        words_typed.add(current_word)
                        
                        # Record that we've typed this word
                        if self.word_memory and current_word:
                            self.word_memory.update_word(current_word)
                            # If the word was typed correctly (no typo), emit signal
                            if not make_typo and current_word in self.word_memory.memory:
                                confidence = self.word_memory.memory[current_word].get('confidence', 0.0)
                                if not self.silent_mode:
                                    self.word_learned.emit(current_word, confidence)
                    
                    # type or emoji-paste with personality-specific handling
                    if emoji.is_emoji(ch):
                        # Apply emoji handling style from personality
                        if self.emoji_handling == "pause":
                            # Pause briefly before emoji (as if considering)
                            time.sleep(random.uniform(0.2, 0.5))
                        elif self.emoji_handling == "confused":
                            # Act confused by emoji, pause longer, and maybe retry
                            time.sleep(random.uniform(0.5, 1.0))
                            if random.random() < 0.3:  # 30% chance to "retry"
                                # Type a space then delete it (simulating confusion)
                                self.typer.type_char(' ')
                                time.sleep(0.2)
                                self.typer.type_char('\b')  # Backspace
                                time.sleep(0.3)
                        
                        # Emoji needs special handling - use paste
                        if not self.typer.paste_text(ch):
                            if not self.silent_mode:
                                self.error.emit("Failed to paste emoji. Checking window focus...")
                            if not self.typer.ensure_window_focus():
                                if not self.silent_mode:
                                    self.error.emit("Lost focus and could not refocus. Aborting.")
                                break
                    else:
                        if not self.typer.type_char(ch):
                            if not self.silent_mode:
                                self.error.emit("Failed to type character. Checking window focus...")
                            if not self.typer.ensure_window_focus():
                                if not self.silent_mode:
                                    self.error.emit("Lost focus and could not refocus. Aborting.")
                                break                                                    # Add rhythm variation if personality uses it
                            actual_delay = self.delay
                            if self.uses_rhythm_variation:
                                # Vary the delay slightly for more natural rhythm
                                actual_delay = self.delay * random.uniform(0.8, 1.2)
                            time.sleep(actual_delay)

                    # punctuation pause
                    if ch in ".!?," and random.random() < self.punc_pause_prob:
                        # Longer pause if personality is a careful typist
                        if self.correction_style == "immediate":
                            time.sleep(random.uniform(0.1, 0.3))
                        else:
                            time.sleep(random.uniform(0.1, 0.25))
                        
                        # Add double space after period if personality does that
                        if ch == '.' and self.uses_double_space and random.random() < 0.8:  # 80% chance
                            self.typer.type_char(" ")
                            time.sleep(self.delay * 0.5)  # Shorter delay for second space
                        
                    # space pause
                    if ch == " " and random.random() < self.space_pause_prob:
                        time.sleep(random.uniform(0.07, 0.18))
                        
                    # thinking pause with personality adjustment
                    if random.random() < self.thinking_pause_prob:
                        # More variation for natural typists
                        if self.uses_rhythm_variation:
                            time.sleep(random.uniform(0.5, 1.8))
                        else:
                            time.sleep(random.uniform(0.7, 1.5))
                    
                    self.current_position += 1
                    self.progress.emit(int((self.current_position / total) * 100))
                    
                except Exception as e:
                    if not self.silent_mode:
                        self.error.emit(f"Error during typing: {e}")
                    # Continue with next character
                    self.current_position += 1
                    continue
            
            self.progress.emit(100 if self.current_position >= total else 0)
            
            # Save the word memory at the end of typing
            if self.word_memory:
                self.word_memory.save_memory()
                stats = self.word_memory.get_stats()
                if not self.silent_mode:
                    self.error.emit(f"Memory stats: {stats['total_words']} words, {stats['total_encounters']} total encounters")
            
            self.finished.emit()
            
            # At the end of typing, show diagnostics if there were any issues
            if not self.silent_mode:
                diagnostic_info = self.typer.get_diagnostic_info()
                self.error.emit(f"Typing complete. Methods used: {diagnostic_info}")
            
        except Exception as e:
            if not self.silent_mode:
                self.error.emit(f"Critical error in typing thread: {e}")
            self.finished.emit()
    
    def stop(self):
        self.running = False

class QuickTemplate(QFrame):
    """Widget for quick text templates"""
    
    template_selected = pyqtSignal(str)
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setFrameShape(QFrame.StyledPanel)
        
        # Templates file
        self.templates_file = "templates.json"
        
        # Templates (load from file if exists, otherwise use defaults)
        self.default_templates = [
            "Hello! How can I help you today?",
            "Thank you for your message. I'll get back to you as soon as possible.",
            "Best regards,\nEyetype4You",
            "This is a test template with emoji 😊👍✨"
        ]
        
        # Load templates (combines defaults with saved custom templates)
        self.templates = self.load_templates()
        
        # Layout
        layout = QVBoxLayout(self)
        layout.setContentsMargins(10, 10, 10, 10)
        layout.setSpacing(5)
        
        # Title
        title_label = QLabel("✏️ Quick Templates")
        title_label.setStyleSheet("font-weight: bold;")
        layout.addWidget(title_label)
        
        # Template buttons (use separate method to allow refreshing)
        self.buttons_layout = QVBoxLayout()
        layout.addLayout(self.buttons_layout)
        self.refresh_template_buttons()
        
        # Add button
        add_btn = QPushButton("➕ Add New")
        add_btn.setObjectName("templateButton")
        add_btn.clicked.connect(self.add_template)
        layout.addWidget(add_btn)
    
    def refresh_template_buttons(self):
        """Clear and recreate template buttons"""
        # First, clear existing buttons
        while self.buttons_layout.count():
            item = self.buttons_layout.takeAt(0)
            widget = item.widget()
            if widget:
                widget.deleteLater()
        
        # Create buttons for each template
        for i, template in enumerate(self.templates):
            # Show first 40 chars
            short_text = template[:40] + ("..." if len(template) > 40 else "")
            btn = QPushButton(short_text)
            btn.setObjectName("templateButton")
            btn.clicked.connect(lambda _, t=template: self.template_selected.emit(t))
            # Help tooltip showing full template
            btn.setToolTip(template.replace("\n", "<br>"))
            self.buttons_layout.addWidget(btn)
    
    def load_templates(self):
        """Load templates from file, merging with defaults"""
        try:
            with open(self.templates_file, "r", encoding="utf-8") as f:
                custom_templates = json.load(f)
                # Combine default and custom templates
                return self.default_templates + custom_templates
        except (FileNotFoundError, json.JSONDecodeError):
            # If file doesn't exist or is invalid, use defaults
            return self.default_templates.copy()
    
    def save_templates(self):
        """Save custom templates to file"""
        # Only save non-default templates
        custom_templates = self.templates[len(self.default_templates):]
        try:
            with open(self.templates_file, "w", encoding="utf-8") as f:
                json.dump(custom_templates, f, indent=2, ensure_ascii=False)
            return True
        except Exception as e:
            print(f"Error saving templates: {e}")
            return False
    
    def add_template(self):
        """Add a new custom template"""
        dialog = QDialog(self)
        dialog.setWindowTitle("Add Custom Template")
        dialog.setMinimumWidth(400)
        
        layout = QVBoxLayout(dialog)
        
        # Instructions
        instructions = QLabel("Enter your custom template text:")
        layout.addWidget(instructions)
        
        # Template text editor
        template_edit = QTextEdit()
        template_edit.setMinimumHeight(150)
        template_edit.setPlaceholderText("Type your template here...")
        layout.addWidget(template_edit)
        
        # Note about emoji
        emoji_note = QLabel("💡 Tip: You can include emoji!")
        layout.addWidget(emoji_note)
        
        # Buttons
        button_layout = QHBoxLayout()
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(dialog.reject)
        
        save_btn = QPushButton("Save Template")
        save_btn.clicked.connect(lambda: self._save_new_template(template_edit.toPlainText(), dialog))
        
        button_layout.addWidget(cancel_btn)
        button_layout.addWidget(save_btn)
        layout.addLayout(button_layout)
        
        dialog.exec_()
    
    def _save_new_template(self, template_text, dialog):
        """Save a new template from dialog input"""
        if not template_text.strip():
            QMessageBox.warning(dialog, "Empty Template", "Please enter some text for your template.")
            return
        
        # Add template to list
        self.templates.append(template_text)
        
        # Save to file
        if self.save_templates():
            # Refresh template buttons
            self.refresh_template_buttons()
            dialog.accept()
        else:
            QMessageBox.warning(dialog, "Save Error", "Failed to save your template. Please try again.")

class StatusIndicator(QFrame):
    """Widget showing current settings status"""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.parent = parent
        
        layout = QHBoxLayout(self)
        layout.setContentsMargins(5, 2, 5, 2)
        
        # Speed indicator
        self.speed_label = QLabel()
        self.speed_label.setObjectName("statusLabel")
        
        # Error rate indicator
        self.error_label = QLabel()
        self.error_label.setObjectName("statusLabel")
        
        # Theme indicator
        self.theme_label = QLabel()
        self.theme_label.setObjectName("statusLabel")
        
        # Background mode indicator
        self.bg_mode_label = QLabel()
        self.bg_mode_label.setObjectName("statusLabel")
        
        # Notepad mode indicator
        self.notepad_mode_label = QLabel()
        self.notepad_mode_label.setObjectName("statusLabel")
        
        # Personality indicator
        self.personality_label = QLabel()
        self.personality_label.setObjectName("statusLabel")
        
        layout.addWidget(self.speed_label)
        layout.addStretch()
        layout.addWidget(self.error_label)
        layout.addStretch()
        layout.addWidget(self.theme_label)
        layout.addStretch()
        layout.addWidget(self.bg_mode_label)
        layout.addStretch()
        layout.addWidget(self.notepad_mode_label)
        layout.addStretch()
        layout.addWidget(self.personality_label)
        
        # Connect to checkbox changes
        if hasattr(parent, 'background_mode_check'):
            parent.background_mode_check.stateChanged.connect(self.update_status)
        if hasattr(parent, 'notepad_mode_check'):
            parent.notepad_mode_check.stateChanged.connect(self.update_status)
        
        self.update_status()
    
    def update_status(self):
        # Update speed
        speed = self.parent.typing_speed
        self.speed_label.setText(f"⚡ Speed: {speed:.2f}s")
        
        # Update error rate
        error = self.parent.error_rate * 100
        self.error_label.setText(f"🎯 Error Rate: {error:.1f}%")
        
        # Update theme
        theme = self.parent.theme
        theme_name = "Cyberpunk" if theme == "cyberpunk" else "Pink City"
        self.theme_label.setText(f"🎨 Theme: {theme_name}")
        
        # Update background mode
        if hasattr(self.parent, 'background_mode_check'):
            bg_mode = "Enabled" if self.parent.background_mode_check.isChecked() else "Disabled"
            self.bg_mode_label.setText(f"🖥️ Background: {bg_mode}")
            
        # Update notepad mode
        if hasattr(self.parent, 'notepad_mode_check'):
            notepad_mode = "Enabled" if self.parent.notepad_mode_check.isChecked() else "Disabled"
            self.notepad_mode_label.setText(f"📝 Notepad: {notepad_mode}")
            
        # Update personality
        if hasattr(self.parent, 'current_personality'):
            self.personality_label.setText(f"🧠 Personality: {self.parent.current_personality.name}")

class SplashScreen(QDialog):
    """A reliable splash screen shown at application startup"""
    
    def __init__(self, parent=None):
        super().__init__(parent, Qt.FramelessWindowHint | Qt.WindowStaysOnTopHint)
        self.setModal(True)
        self.setFixedSize(450, 300)
        
        # Center on screen
        screen_size = QApplication.primaryScreen().geometry()
        self.move((screen_size.width() - self.width()) // 2,
                  (screen_size.height() - self.height()) // 2)
        
        # Set up UI
        layout = QVBoxLayout(self)
        layout.setContentsMargins(20, 20, 20, 20)
        layout.setSpacing(10)
        
        # Eye image
        self.eye_label = QLabel()
        self.eye_label.setAlignment(Qt.AlignCenter)
        try:
            pixmap = QPixmap("assets/eyes.png").scaled(175, 175, Qt.KeepAspectRatio, Qt.SmoothTransformation)
            self.eye_label.setPixmap(pixmap)
        except:
            # Fallback if image is missing
            self.eye_label.setText("👁️ 👁️")
            self.eye_label.setStyleSheet("font-size: 64px;")
        
        # Welcome text
        title = QLabel("Welcome to Eyetype4You")
        title.setAlignment(Qt.AlignCenter)
        title.setStyleSheet("font-size: 24px; font-weight: bold; color: #08d9d6;")
        
        subtitle = QLabel("The intelligent typing assistant")
        subtitle.setAlignment(Qt.AlignCenter)
        subtitle.setStyleSheet("font-size: 16px; color: #f8f8ff;")
        
        # Close button
        self.close_btn = QPushButton("Start Using Eyetype4You")
        self.close_btn.setFixedHeight(40)
        self.close_btn.clicked.connect(self.accept)
        
        # Add all widgets to layout
        layout.addWidget(self.eye_label)
        layout.addWidget(title)
        layout.addWidget(subtitle)
        layout.addWidget(self.close_btn)
        
        # Set dark background
        self.setStyleSheet("""
            QDialog {
                background-color: #10101a;
                border: 2px solid #08d9d6;
                border-radius: 10px;
            }
            QPushButton {
                background-color: #08d9d6;
                color: #1a1a2e;
                border: none;
                border-radius: 8px;
                font-weight: bold;
                font-size: 16px;
            }
            QPushButton:hover {
                background-color: #20e7e4;
            }
        """)
        
        # Auto-close after 5 seconds
        QTimer.singleShot(5000, self.accept)

class TypingBot(QMainWindow):
    def __init__(self):
        super().__init__()
        
        # Setup main window
        self.setWindowTitle("Eyetype4You Bot")
        self.setGeometry(100, 100, 800, 600)
        
        # Create WordMemory instance
        self.word_memory = WordMemory("word_memory.json")
        
        # Typing parameters
        self.error_rate = 1/83
        self.punc_pause_prob = 0.18
        self.space_pause_prob = 0.08
        self.thinking_pause_prob = 0.025
        self.theme = 'cyberpunk'  # Default theme
        self.current_personality = BotPersonality("natural_typist")  # Default personality
        self.typing_thread = None
        self.typing_speed = 0.12  # Default typing speed in seconds
        
        # Create the main widget and layout
        self.central_widget = QWidget()
        self.setCentralWidget(self.central_widget)
        self.main_layout = QVBoxLayout(self.central_widget)
        
        # Setup UI components
        self.setup_menu()
        self.setup_ui()
        
        # Initialize bot manager
        self.setup_multi_bot()
        
        # Apply theme
        self.apply_theme()
        
        # Show splash screen
        splash = SplashScreen(self)
        splash.exec_()
        
        # Load memory stats and log
        stats = self.word_memory.get_stats()
        print(f"Loaded word memory: {stats['total_words']} words")
    
    def setup_multi_bot(self):
        """Initialize the bot manager and add multi-bot menu items"""
        # Create bot manager
        self.bot_manager = BotManager(max_concurrent=3)
        
        # Add multi-bot menu
        multi_menu = self.menuBar().addMenu("🤖 Multi-Bot")
        
        # Add actions
        manage_action = QAction("Manage Bots", self)
        manage_action.triggered.connect(self.show_bot_manager)
        multi_menu.addAction(manage_action)
        
        # Add shortcuts
        duplicate_action = QAction("Add Bot with Current Settings", self)
        duplicate_action.triggered.connect(self.duplicate_current)
        multi_menu.addAction(duplicate_action)
    
    def show_bot_manager(self):
        """Show the multi-bot manager dialog"""
        dialog = MultiBotDialog(self, self.bot_manager)
        dialog.exec_()
    
    def duplicate_current(self):
        """Create a new bot with current settings"""
        text = self.text_edit.toPlainText()
        if not text.strip():
            QMessageBox.warning(self, "No Text", "Please enter text to type.")
            return
            
        settings = {
            'delay': self.typing_speed,
            'error_rate': self.error_rate,
            'punc_pause_prob': self.punc_pause_prob,
            'space_pause_prob': self.space_pause_prob,
            'thinking_pause_prob': self.thinking_pause_prob,
            'background_mode': True,  # Always true for multi-bot
            'notepad_mode': self.notepad_mode_check.isChecked(),
            'word_memory': self.word_memory,
            # Add personality parameters
            'personality_id': self.current_personality.id,
            'personality_name': self.current_personality.name,
            'correction_style': self.current_personality.correction_style,
            'emoji_handling': self.current_personality.emoji_handling,
            'is_code_aware': self.current_personality.is_code_aware,
            'uses_rhythm_variation': self.current_personality.uses_rhythm_variation,
            'common_misspellings': self.current_personality.common_misspellings
        }
        
        # Get a name for the bot
        name, ok = QInputDialog.getText(self, "Bot Name", "Enter a name for this bot:")
        if not ok:
            return
            
        # Add the bot task
        self.bot_manager.add_bot_task(text, settings, name)
        
        # Show confirmation
        QMessageBox.information(self, "Bot Added", f"Bot added to the queue.\nUse 'Manage Bots' to view status.")
    
    def setup_menu(self):
        menubar = self.menuBar()
        
        # Create Settings menu as parent
        settings_menu = menubar.addMenu("⚙️ Settings")
        
        # Add Speed submenu
        speed_menu = settings_menu.addMenu("⚡ Speed")
        
        # Add speed presets
        speed_slow = QAction("Slow (0.20s)", self)
        speed_slow.triggered.connect(lambda: self.set_speed(20))
        
        speed_normal = QAction("Normal (0.12s)", self)
        speed_normal.triggered.connect(lambda: self.set_speed(12))
        
        speed_fast = QAction("Fast (0.08s)", self)
        speed_fast.triggered.connect(lambda: self.set_speed(8))
        
        speed_very_fast = QAction("Very Fast (0.05s)", self)
        speed_very_fast.triggered.connect(lambda: self.set_speed(5))
        
        # Add custom speed option
        speed_custom = QAction("Custom Speed...", self)
        speed_custom.triggered.connect(self.open_speed_dialog)
        
        # Add actions to speed menu
        speed_menu.addAction(speed_slow)
        speed_menu.addAction(speed_normal)
        speed_menu.addAction(speed_fast)
        speed_menu.addAction(speed_very_fast)
        speed_menu.addSeparator()
        speed_menu.addAction(speed_custom)
        
        # Add Errors submenu
        errors_menu = settings_menu.addMenu("🎯 Errors")
        
        # Add error rate presets
        errors_none = QAction("No Errors (0%)", self)
        errors_none.triggered.connect(lambda: self.set_error_rate(0))
        
        errors_low = QAction("Low (1%)", self)
        errors_low.triggered.connect(lambda: self.set_error_rate(1))
        
        errors_medium = QAction("Medium (2%)", self)
        errors_medium.triggered.connect(lambda: self.set_error_rate(2))
        
        errors_high = QAction("High (5%)", self)
        errors_high.triggered.connect(lambda: self.set_error_rate(5))
        
        # Add custom error rate option
        errors_custom = QAction("Custom Error Rate...", self)
        errors_custom.triggered.connect(self.open_error_dialog)
        
        # Add actions to errors menu
        errors_menu.addAction(errors_none)
        errors_menu.addAction(errors_low)
        errors_menu.addAction(errors_medium)
        errors_menu.addAction(errors_high)
        errors_menu.addSeparator()
        errors_menu.addAction(errors_custom)
        
        # Add theme option
        theme_menu = settings_menu.addMenu("🎨 Theme")
        
        self.theme_group = []
        theme_cyberpunk = QAction("Cyberpunk (Dark City)", self)
        theme_cyberpunk.setCheckable(True)
        theme_cyberpunk.triggered.connect(lambda: self.set_theme("cyberpunk"))
        theme_menu.addAction(theme_cyberpunk)
        self.theme_group.append(theme_cyberpunk)
        theme_pink = QAction("Pink City (Light)", self)
        theme_pink.setCheckable(True)
        theme_pink.triggered.connect(lambda: self.set_theme("pink"))
        theme_menu.addAction(theme_pink)
        self.theme_group.append(theme_pink)
        
        # Add autocorrect toggle
        theme_menu.addSeparator()
        self.autocorrect_action = QAction("✅ Autocorrect", self)
        self.autocorrect_action.setCheckable(True)
        self.autocorrect_action.setChecked(True)
        self.autocorrect_action.triggered.connect(self.toggle_autocorrect)
        theme_menu.addAction(self.autocorrect_action)
        
        # Set default checked
        if getattr(self, 'theme', 'cyberpunk') == 'cyberpunk':
            theme_cyberpunk.setChecked(True)
        else:
            theme_pink.setChecked(True)
            
        # Add personality menu item
        personality_action = QAction("🤖 Bot Personalities", self)
        personality_action.triggered.connect(self.show_personality_dialog)
        settings_menu.addAction(personality_action)
            
        # Add word memory menu
        self.add_word_memory_menu()
    
    def add_word_memory_menu(self):
        """Add a word memory menu to settings"""
        # Add to existing menu setup
        menubar = self.menuBar()
        memory_menu = menubar.addMenu("🧠 Word Memory")
        
        # Add actions
        view_stats = QAction("View Statistics", self)
        view_stats.triggered.connect(self.show_memory_stats)
        
        view_difficult = QAction("View Difficult Words", self)
        view_difficult.triggered.connect(self.show_difficult_words)
        
        reset_memory = QAction("Reset Memory", self)
        reset_memory.triggered.connect(self.reset_memory)
        
        memory_menu.addAction(view_stats)
        memory_menu.addAction(view_difficult)
        memory_menu.addSeparator()
        memory_menu.addAction(reset_memory)
    
    def show_memory_stats(self):
        """Show word memory statistics"""
        stats = self.word_memory.get_stats()
        confidence_levels = stats['confidence_levels']
        
        dialog = QDialog(self)
        dialog.setWindowTitle("Word Memory Statistics")
        dialog.setFixedSize(400, 300)
        
        layout = QVBoxLayout(dialog)
        
        # Stats labels
        title = QLabel("Your Typing Memory Stats")
        title.setObjectName("titleLabel")
        title.setAlignment(Qt.AlignCenter)
        
        total_words = QLabel(f"Total Words: {stats['total_words']}")
        total_encounters = QLabel(f"Total Encounters: {stats['total_encounters']}")
        
        # Confidence level breakdown
        confidence_title = QLabel("Confidence Levels:")
        confidence_title.setStyleSheet("font-weight: bold;")
        
        low_conf = QLabel(f"Low Confidence (0-30%): {confidence_levels['low']} words")
        med_conf = QLabel(f"Medium Confidence (30-70%): {confidence_levels['medium']} words")
        high_conf = QLabel(f"High Confidence (70-100%): {confidence_levels['high']} words")
        
        # Add explanation
        explanation = QLabel("As you type, the bot learns which words you use frequently and "
                           "becomes more confident typing them. Words with higher confidence "
                           "are typed with fewer errors and pauses.")
        explanation.setWordWrap(True)
        
        # Add all to layout
        layout.addWidget(title)
        layout.addWidget(total_words)
        layout.addWidget(total_encounters)
        layout.addWidget(confidence_title)
        layout.addWidget(low_conf)
        layout.addWidget(med_conf)
        layout.addWidget(high_conf)
        layout.addWidget(explanation)
        
        # Close button
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(dialog.accept)
        layout.addWidget(close_btn, alignment=Qt.AlignCenter)
        
        dialog.exec_()
    
    def show_difficult_words(self):
        """Show words with low confidence scores"""
        difficult_words = self.word_memory.get_words_by_confidence(threshold=0.5, limit=20)
        
        dialog = QDialog(self)
        dialog.setWindowTitle("Difficult Words")
        dialog.setFixedSize(400, 400)
        
        layout = QVBoxLayout(dialog)
        
        title = QLabel("Words You Find Difficult")
        title.setObjectName("titleLabel")
        title.setAlignment(Qt.AlignCenter)
        layout.addWidget(title)
        
        if not difficult_words:
            no_words = QLabel("No difficult words found in memory yet.\nKeep typing to build up your word memory!")
            no_words.setAlignment(Qt.AlignCenter)
            layout.addWidget(no_words)
        else:
            # Table-like display with word, confidence, and encounter count
            word_list = QTextEdit()
            word_list.setReadOnly(True)
            
            # Create table header
            table = "Word\tConfidence\tEncounters\n"
            table += "-" * 40 + "\n"
            
            # Add each word
            for word, confidence, encounters in difficult_words:
                table += f"{word}\t{confidence:.2f}\t{encounters}\n"
                
            word_list.setText(table)
            layout.addWidget(word_list)
            
            # Add explanation
            explanation = QLabel("These are words the bot finds difficult to type. The more "
                                "you use these words, the more confident the bot will become "
                                "typing them, leading to fewer errors and pauses.")
            explanation.setWordWrap(True)
            layout.addWidget(explanation)
        
        # Close button
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(dialog.accept)
        layout.addWidget(close_btn, alignment=Qt.AlignCenter)
        
        dialog.exec_()
    
    def reset_memory(self):
        """Reset the word memory after confirmation"""
        confirm = QMessageBox.question(
            self, "Confirm Reset", 
            "Are you sure you want to reset your word memory?\nThis will erase all learning progress.",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )
        
        if confirm == QMessageBox.Yes:
            # Create empty memory
            with open(self.word_memory.memory_file, "w", encoding="utf-8") as f:
                f.write("{}")
            
            # Reload memory
            self.word_memory = WordMemory(self.word_memory.memory_file)
            
            QMessageBox.information(self, "Memory Reset", "Word memory has been reset successfully.")
    
    def handle_word_learned(self, word, confidence):
        """Handle signal when a word's confidence has changed"""
        # This could be used to update UI or show notifications
        # For now, just log it
        print(f"Learned word: {word} - Confidence: {confidence:.2f}")
    
    def setup_ui(self):
        # Bot image with reference
        self.eye_label = QLabel()
        self.eye_label.setAlignment(Qt.AlignCenter)
        try:
            pixmap = QPixmap("assets/eyes.png").scaled(175, 175, Qt.KeepAspectRatio, Qt.SmoothTransformation)
            self.eye_label.setPixmap(pixmap)
        except:
            # Fallback if image is missing
            self.eye_label.setText("👁️ 👁️")
            self.eye_label.setStyleSheet("font-size: 64px;")
        
        # Control buttons with tooltips
        button_layout = QHBoxLayout()
        
        self.start_button = QPushButton("▶️ Start Typing")
        self.start_button.setFixedSize(140, 50)
        self.start_button.setToolTip("Click to begin typing your text.<br>You'll have 4 seconds to focus on your target window.")
        self.start_button.clicked.connect(self.start_typing)
        
        self.close_button = QPushButton("✖ Close")
        self.close_button.setObjectName("closeButton")
        self.close_button.setFixedSize(140, 50)
        self.close_button.setFont(QFont("Segoe UI", 14, QFont.Bold))
        self.close_button.clicked.connect(self.close)
        
        # Background mode checkbox
        self.background_mode_check = QCheckBox("Background Typing Mode")
        self.background_mode_check.setToolTip("When enabled, typing continues in the target window<br>even if you're working in other windows.")
        
        # Notepad mode checkbox
        self.notepad_mode_check = QCheckBox("Notepad/Text Editor Mode")
        self.notepad_mode_check.setToolTip("Enable this when typing into Notepad, Notepad++, or other text editors.<br>Uses special methods that work better with these applications.")
        
        # Progress bar with percentage label
        progress_layout = QVBoxLayout()
        self.progress_bar = QProgressBar()
        self.progress_bar.setFixedSize(80, 15)
        self.progress_bar.setValue(0)
        
        self.progress_label = QLabel("0%")
        self.progress_label.setAlignment(Qt.AlignCenter)
        
        progress_layout.addWidget(self.progress_bar)
        progress_layout.addWidget(self.progress_label)
        progress_layout.setAlignment(Qt.AlignCenter)
        
        # Status indicator
        self.status_indicator = StatusIndicator(self)
        
        # Main content layout
        content_layout = QHBoxLayout()
        
        # Text edit area with placeholder and autocorrect
        self.text_edit = AutoCorrectTextEdit(self)
        self.text_edit.setPlaceholderText("Enter text to type...\n\nTip: You can include emoji like 😊 👍 ⭐\n\nAutocorrect is enabled - common misspellings will be fixed as you type!")
        
        # Quick templates sidebar
        self.templates_widget = QuickTemplate(self)
        self.templates_widget.template_selected.connect(self.insert_template)
        
        content_layout.addWidget(self.text_edit, 3)
        content_layout.addWidget(self.templates_widget, 1)
        
        # Add everything to main layout
        self.main_layout.addWidget(self.eye_label)
        
        # Put buttons and checkbox in same row
        controls_row = QHBoxLayout()
        controls_row.addWidget(self.start_button)
        
        # Stack checkboxes vertically in a container
        checkbox_layout = QVBoxLayout()
        checkbox_layout.addWidget(self.background_mode_check)
        checkbox_layout.addWidget(self.notepad_mode_check)
        checkbox_container = QWidget()
        checkbox_container.setLayout(checkbox_layout)
        
        controls_row.addWidget(checkbox_container)
        controls_row.addWidget(self.close_button)
        controls_row.addStretch()
        controls_row.addLayout(progress_layout)
        
        self.main_layout.addLayout(controls_row)
        self.main_layout.addWidget(self.status_indicator)
        self.main_layout.addLayout(content_layout)
    
    def insert_template(self, template_text):
        """Insert template text at cursor position"""
        self.text_edit.insertPlainText(template_text)
    
    def update_progress(self, value):
        self.progress_bar.setValue(value)
        self.progress_label.setText(f"{value}%")
    
    def set_error_rate(self, value):
        """Set the error rate to a specific percentage"""
        self.error_rate = value / 100
        if hasattr(self, 'status_indicator'):
            self.status_indicator.update_status()
    
    def set_speed(self, value):
        """Set the typing speed in seconds (value is 1-50, representing 0.01s to 0.50s)"""
        self.typing_speed = value / 100
        if hasattr(self, 'status_indicator'):
            self.status_indicator.update_status()
    
    def set_theme(self, theme_name):
        """Switch between themes and update all widgets"""
        self.theme = theme_name
        # Uncheck all, check only the selected
        for action in self.theme_group:
            action.setChecked(False)
        if theme_name == "cyberpunk":
            self.theme_group[0].setChecked(True)
        else:
            self.theme_group[1].setChecked(True)
        self.apply_theme()
        if hasattr(self, 'status_indicator'):
            self.status_indicator.update_status()
    
    def apply_theme(self):
        # Apply stylesheet for the selected theme
        if getattr(self, 'theme', 'cyberpunk') == 'cyberpunk':
            self.setStyleSheet(StyleSheet.CYBERPUNK)
        else:
            self.setStyleSheet(StyleSheet.PINK_CITY)
    
    def load_memory(self) -> Dict:
        try:
            with open("word_memory.json", "r", encoding="utf-8") as f:
                return json.load(f)
        except FileNotFoundError:
            return {}
    
    def save_memory(self) -> None:
        with open("word_memory.json", "w", encoding="utf-8") as f:
            json.dump(self.word_memory, f, indent=2)
    
    def show_popup(self, title, message, kind="info"):
        dialog = PopupDialog(self, title, message, kind)
        dialog.exec_()
    
    def open_settings(self):
        dialog = SettingsDialog(self, self.error_rate, self.dark_mode)
        dialog.exec_()
    
    def start_typing(self):
        text = self.text_edit.toPlainText().strip()
        if not text:
            self.show_popup("Warning", "Enter text first!", kind="warn")
            return
        
        delay = self.typing_speed
        
        # Check if special modes are enabled
        background_mode = self.background_mode_check.isChecked()
        notepad_mode = self.notepad_mode_check.isChecked()
        
        # Create instructions based on modes
        if background_mode:
            instructions = "Click into the target window within 2 seconds.\nYou can work in other windows while typing continues in the background."
        else:
            instructions = "Click into the target window within 2 seconds.\nThe typing will stay in that window even if you click elsewhere."
            
        if notepad_mode:
            instructions += "\nNotepad/Text Editor Mode is enabled for better compatibility."
            
        # Include personality info in instructions
        instructions += f"\n\nUsing '{self.current_personality.name}' personality."
            
        self.show_popup("Ready", instructions)
        
        # Start typing in a separate thread
        if self.typing_thread and self.typing_thread.isRunning():
            self.typing_thread.stop()
            self.typing_thread.wait()
        
        # Get additional personality parameters
        params = self.current_personality.get_typing_parameters()
        
        self.typing_thread = TypingThread(
            text, delay, self.error_rate, 
            self.punc_pause_prob, self.space_pause_prob, 
            self.thinking_pause_prob,
            background_mode,
            notepad_mode,
            word_memory=self.word_memory  # Pass WordMemory instance to thread
        )
        
        # Set additional personality attributes if the typing thread supports them
        if hasattr(self.typing_thread, 'correction_style'):
            self.typing_thread.correction_style = params.get('correction_style', 'immediate')
        if hasattr(self.typing_thread, 'emoji_handling'):
            self.typing_thread.emoji_handling = params.get('emoji_handling', 'direct')
        if hasattr(self.typing_thread, 'is_code_aware'):
            self.typing_thread.is_code_aware = params.get('is_code_aware', False)
        if hasattr(self.typing_thread, 'uses_rhythm_variation'):
            self.typing_thread.uses_rhythm_variation = params.get('uses_rhythm_variation', False)
        if hasattr(self.typing_thread, 'common_misspellings'):
            self.typing_thread.common_misspellings = params.get('common_misspellings', [])
        
        self.typing_thread.progress.connect(self.update_progress)
        self.typing_thread.finished.connect(self.typing_finished)
        self.typing_thread.error.connect(self.handle_typing_error)
        self.typing_thread.word_learned.connect(self.handle_word_learned)
        self.typing_thread.start()
    
    def handle_typing_error(self, error_msg):
        """Handle errors from typing thread"""
        print(f"Error: {error_msg}")
        
        # Display critical errors as popups
        if any(critical in error_msg for critical in 
              ["Invalid target window", "Lost focus", "Failed to", "Aborting"]):
            # Use QTimer to ensure this runs on the main thread
            QTimer.singleShot(0, lambda: self.show_popup("Typing Error", error_msg, kind="warn"))
        
        # Let other errors just appear in the status message
    
    def typing_finished(self):
        self.progress_bar.setValue(0)
        self.progress_label.setText("0%")
        self.show_popup("Done", "Typing complete!")
        
        # Save memory
        self.word_memory.save_memory()
        
        # Show memory stats in popup
        stats = self.word_memory.get_stats()
        confidence_levels = stats['confidence_levels']
        memory_msg = (f"Words in memory: {stats['total_words']}\n"
                     f"Low confidence: {confidence_levels['low']}\n"
                     f"Medium confidence: {confidence_levels['medium']}\n"
                     f"High confidence: {confidence_levels['high']}")
        
        self.show_popup("Memory Stats", memory_msg)
    
    def toggle_autocorrect(self, checked):
        """Toggle autocorrect functionality"""
        if hasattr(self, 'text_edit') and isinstance(self.text_edit, AutoCorrectTextEdit):
            self.text_edit.toggle_autocorrect(checked)
    
    def show_personality_dialog(self):
        """Show the personality selection dialog"""
        # Get the current personality ID
        current_id = self.current_personality.id
        
        # Create and show the dialog
        dialog = PersonalityDialog(self, current_id)
        dialog.personality_selected.connect(self.apply_personality)
        dialog.exec_()
    
    def apply_personality(self, personality_id):
        """Apply a selected personality to the bot"""
        # Load the personality
        self.current_personality = BotPersonality(personality_id)
        
        # Update typing parameters based on personality
        params = self.current_personality.get_typing_parameters()
        self.typing_speed = params["delay"]
        self.error_rate = params["error_rate"]
        self.punc_pause_prob = params["punc_pause_prob"]
        self.space_pause_prob = params["space_pause_prob"]
        self.thinking_pause_prob = params["thinking_pause_prob"]
        
        # Update status indicator
        if hasattr(self, 'status_indicator'):
            self.status_indicator.update_status()
            
        # Show confirmation to user
        self.show_popup("Personality Applied", 
                      f"Now using: {self.current_personality.name}\n{self.current_personality.description}")
    
    def open_error_dialog(self):
        """Open a dialog to set custom error rate"""
        current_rate = int(self.error_rate * 100)
        
        dialog = QDialog(self)
        dialog.setWindowTitle("Custom Error Rate")
        dialog.setFixedSize(300, 150)
        
        layout = QVBoxLayout(dialog)
        
        # Add a horizontal slider for error rate
        slider_layout = QHBoxLayout()
        slider = QSlider(Qt.Horizontal)
        slider.setMinimum(0)
        slider.setMaximum(20)
        slider.setValue(current_rate)
        
        # Add labels
        slider_layout.addWidget(QLabel("Low"))
        slider_layout.addWidget(slider)
        slider_layout.addWidget(QLabel("High"))
        
        # Add value display
        value_label = QLabel(f"{current_rate}%")
        value_label.setAlignment(Qt.AlignCenter)
        
        # Update value label when slider changes
        def update_label(value):
            value_label.setText(f"{value}%")
        
        slider.valueChanged.connect(update_label)
        
        # Add buttons
        button_layout = QHBoxLayout()
        cancel_button = QPushButton("Cancel")
        cancel_button.clicked.connect(dialog.reject)
        
        apply_button = QPushButton("Apply")
        apply_button.clicked.connect(lambda: self.apply_custom_error_rate(slider.value(), dialog))
        
        button_layout.addWidget(cancel_button)
        button_layout.addWidget(apply_button)
        
        # Add all widgets to main layout
        layout.addLayout(slider_layout)
        layout.addWidget(value_label)
        layout.addLayout(button_layout)
        
        dialog.exec_()
    
    def apply_custom_error_rate(self, value, dialog):
        """Apply the custom error rate and close the dialog"""
        self.set_error_rate(value)
        dialog.accept()
        
    def open_speed_dialog(self):
        """Open a dialog to set custom speed"""
        current_speed = int(self.typing_speed * 100)
        dialog = QDialog(self)
        dialog.setWindowTitle("Custom Speed")
        dialog.setFixedSize(300, 150)
        layout = QVBoxLayout(dialog)
        # Add a horizontal slider for speed
        slider_layout = QHBoxLayout()
        slider = QSlider(Qt.Horizontal)
        slider.setMinimum(1)
        slider.setMaximum(50)
        slider.setValue(current_speed)
        # Add labels
        slider_layout.addWidget(QLabel("Fast"))
        slider_layout.addWidget(slider)
        slider_layout.addWidget(QLabel("Slow"))
        # Add value display
        value_label = QLabel(f"{current_speed/100:.2f}s")
        value_label.setAlignment(Qt.AlignCenter)
        # Update value label when slider changes
        def update_label(value):
            value_label.setText(f"{value/100:.2f}s")
        slider.valueChanged.connect(update_label)
        # Add buttons
        button_layout = QHBoxLayout()
        cancel_button = QPushButton("Cancel")
        cancel_button.clicked.connect(dialog.reject)
        apply_button = QPushButton("Apply")
        apply_button.clicked.connect(lambda: self.apply_custom_speed(slider.value(), dialog))
        button_layout.addWidget(cancel_button)
        button_layout.addWidget(apply_button)
        # Add all widgets to main layout
        layout.addLayout(slider_layout)
        layout.addWidget(value_label)
        layout.addLayout(button_layout)
        dialog.exec_()
    
    def apply_custom_speed(self, value, dialog):
        """Apply the custom speed and close the dialog"""
        self.set_speed(value)
        dialog.accept()
    
    def closeEvent(self, event):
        # Save word memory before closing
        if hasattr(self, 'word_memory'):
            self.word_memory.save_memory()
            
        if self.typing_thread and self.typing_thread.isRunning():
            self.typing_thread.stop()
            self.typing_thread.wait()
        event.accept()
    
    def update_word_memory(self, word, confidence):
        """Update word memory based on new confidence"""
        if self.word_memory:
            self.word_memory.update_word(word, confidence)

class PopupDialog(QDialog):
    def __init__(self, parent, title, message, kind="info"):
        super().__init__(parent)
        self.setWindowTitle(title)
        self.setFixedSize(420, 180)
        self.setModal(True)
        
        layout = QVBoxLayout()
        self.setLayout(layout)
        
        title_label = QLabel(title)
        title_label.setObjectName("titleLabel")
        title_label.setAlignment(Qt.AlignCenter)
        
        message_label = QLabel(message)
        message_label.setAlignment(Qt.AlignCenter)
        message_label.setWordWrap(True)
        
        button = QPushButton("OK")
        button.setFixedSize(120, 40)
        if kind != "info":
            button.setObjectName("closeButton")
        button.clicked.connect(self.accept)
        
        layout.addWidget(title_label, alignment=Qt.AlignCenter)
        layout.addWidget(message_label, alignment=Qt.AlignCenter)
        layout.addWidget(button, alignment=Qt.AlignCenter)
        layout.setContentsMargins(20, 20, 20, 20)
        layout.setSpacing(15)

class SettingsDialog(QDialog):
    def __init__(self, parent, error_rate, dark_mode):
        super().__init__(parent)
        self.setWindowTitle("Preferences")
        self.setFixedSize(300, 200)
        
        self.parent = parent
        self.error_rate = error_rate
        self.dark_mode = dark_mode
        
        layout = QVBoxLayout()
        self.setLayout(layout)
        
        error_label = QLabel("Error rate (%)")
        
        self.error_slider = QSlider(Qt.Horizontal)
        self.error_slider.setMinimum(0)
        self.error_slider.setMaximum(20)
        self.error_slider.setValue(int(error_rate * 100))
        self.error_slider.valueChanged.connect(self.update_error_rate)
        
        self.dark_mode_check = QCheckBox("Dark Mode")
        self.dark_mode_check.setChecked(dark_mode)
        self.dark_mode_check.toggled.connect(self.toggle_dark_mode)
        
        close_button = QPushButton("Close")
        close_button.clicked.connect(self.accept)
        close_button.setFixedSize(120, 40)
        
        layout.addWidget(error_label, alignment=Qt.AlignCenter)
        layout.addWidget(self.error_slider)
        layout.addWidget(self.dark_mode_check)
        layout.addWidget(close_button, alignment=Qt.AlignCenter)
        layout.setContentsMargins(20, 20, 20, 20)
        layout.setSpacing(15)
    
    def update_error_rate(self, value):
        self.error_rate = value / 100
        self.parent.error_rate = self.error_rate
    
    def toggle_dark_mode(self, checked):
        self.dark_mode = checked
        self.parent.dark_mode = checked
        self.parent.apply_theme()

class BotManager:
    """Manages multiple typing bots for concurrent operation"""
    
    def __init__(self, max_concurrent=3):
        self.max_concurrent = max_concurrent
        self.active_bots = {}  # Dict of task_id: TypingThread
        self.bot_queue = []  # List of (task_id, text, settings) tuples
        self.pending_count = 0
        self.completed_count = 0
        self.status_change_callbacks = []  # For UI updates
        self.focus_manager_running = False
        self.focus_manager_thread = None
        self.bot_errors = {}  # Dict of task_id: list of error messages
        self.bot_progress = {}  # Dict of task_id: progress percentage
    
    def add_bot_task(self, text, settings, name=None):
        """Add a typing task to the queue"""
        task_id = f"bot_{len(self.bot_queue) + len(self.active_bots) + 1}"
        if name:
            task_id = name
        self.bot_queue.append((task_id, text, settings))
        self.pending_count += 1
        self._process_queue()
        return task_id
    
    def add_status_callback(self, callback):
        """Add a callback function to be called when status changes"""
        self.status_change_callbacks.append(callback)
    
    def _notify_status_change(self):
        """Notify all callbacks of status change"""
        for callback in self.status_change_callbacks:
            callback()
    
    def _process_queue(self):
        """Start new bots if slots are available"""
        while len(self.active_bots) < self.max_concurrent and self.bot_queue:
            task_id, text, settings = self.bot_queue.pop(0)
            # Create a new typing thread with settings
            thread = TypingThread(
                text=text,
                delay=settings.get('delay', 0.12),
                error_rate=settings.get('error_rate', 1/83),
                punc_pause_prob=settings.get('punc_pause_prob', 0.18),
                space_pause_prob=settings.get('space_pause_prob', 0.08),
                thinking_pause_prob=settings.get('thinking_pause_prob', 0.025),
                background_mode=settings.get('background_mode', True),  # Always use background mode for multi-bot
                notepad_mode=settings.get('notepad_mode', False),
                word_memory=settings.get('word_memory', None)
            )
            
            # Set personality attributes if available
            if 'correction_style' in settings:
                if hasattr(thread, 'correction_style'):
                    thread.correction_style = settings.get('correction_style')
            if 'emoji_handling' in settings:
                if hasattr(thread, 'emoji_handling'):
                    thread.emoji_handling = settings.get('emoji_handling')
            if 'is_code_aware' in settings:
                if hasattr(thread, 'is_code_aware'):
                    thread.is_code_aware = settings.get('is_code_aware')
            if 'uses_rhythm_variation' in settings:
                if hasattr(thread, 'uses_rhythm_variation'):
                    thread.uses_rhythm_variation = settings.get('uses_rhythm_variation')
            if 'common_misspellings' in settings:
                if hasattr(thread, 'common_misspellings'):
                    thread.common_misspellings = settings.get('common_misspellings')
                    
            # Set to silent mode for multi-bot
            thread.set_silent_mode(True)
            
            # Setup error tracking
            self.bot_errors[task_id] = []
            self.bot_progress[task_id] = 0
            
            # Connect signals with unique task_id lambda capture
            thread.finished.connect(lambda tid=task_id: self._bot_finished(tid))
            thread.error.connect(lambda msg, tid=task_id: self._bot_error(tid, msg))
            thread.progress.connect(lambda prog, tid=task_id: self._bot_progress(tid, prog))
            
            # Store and start
            self.active_bots[task_id] = thread
            thread.start()
            
            self._notify_status_change()
            
            # Start focus manager if not already running
            self._ensure_focus_manager()
    
    def _bot_progress(self, task_id, progress):
        """Update progress for a specific bot"""
        self.bot_progress[task_id] = progress
        self._notify_status_change()
    
    def _bot_error(self, task_id, error_msg):
        """Handle bot errors"""
        print(f"Bot {task_id} error: {error_msg}")
        # Store the error message
        if task_id in self.bot_errors:
            self.bot_errors[task_id].append(error_msg)
            # Keep only last 5 errors
            if len(self.bot_errors[task_id]) > 5:
                self.bot_errors[task_id] = self.bot_errors[task_id][-5:]
        self._notify_status_change()
    
    def _bot_finished(self, task_id):
        """Handle bot completion"""
        if task_id in self.active_bots:
            thread = self.active_bots.pop(task_id)
            # Clean up thread
            thread.wait()
            self.completed_count += 1
            # Process next in queue
            self._process_queue()
            self._notify_status_change()
    
    def _ensure_focus_manager(self):
        """Start the focus manager thread if not already running"""
        if len(self.active_bots) > 1 and not self.focus_manager_running:
            self.focus_manager_running = True
            self.focus_manager_thread = threading.Thread(target=self._focus_manager_loop)
            self.focus_manager_thread.daemon = True
            self.focus_manager_thread.start()
    
    def _focus_manager_loop(self):
        """Loop that manages focus for multiple bots"""
        try:
            while self.focus_manager_running and len(self.active_bots) > 0:
                self._manage_focus_for_bots()
                time.sleep(0.5)  # Check focus every half second
        except Exception as e:
            print(f"Error in focus manager: {e}")
        finally:
            self.focus_manager_running = False
    
    def _manage_focus_for_bots(self):
        """Handle window focus for multiple bots"""
        # Group bots by target window
        window_groups = {}
        for bot_id, bot in list(self.active_bots.items()):
            if not hasattr(bot, 'target_window') or not bot.target_window:
                continue
                
            # Skip bots in background mode
            if bot.background_mode:
                continue
                
            if bot.target_window not in window_groups:
                window_groups[bot.target_window] = []
                
            window_groups[bot.target_window].append(bot_id)
        
        # If only one window or all bots are in background mode, no need for focus management
        if len(window_groups) <= 1:
            return
            
        # Round-robin focus between windows
        for window, bot_ids in window_groups.items():
            if not user32.IsWindow(window):
                continue
                
            # Set focus to this window
            user32.SetForegroundWindow(window)
            time.sleep(0.2)  # Allow OS to register focus change
            
            # Give each bot in this window a chance to type
            for bot_id in bot_ids:
                if bot_id in self.active_bots:
                    bot = self.active_bots[bot_id]
                    # Let the bot type for a short time slice
                    if hasattr(bot, 'type_for_timeslice'):
                        bot.type_for_timeslice(0.3)  # Type for 0.3 seconds
    
    def stop_bot(self, task_id):
        """Stop a specific bot"""
        if task_id in self.active_bots:
            thread = self.active_bots[task_id]
            thread.stop()
            thread.wait()
            self.active_bots.pop(task_id)
            self._notify_status_change()
            # Process queue in case there are pending bots
            self._process_queue()
            return True
        return False
    
    def stop_all(self):
        """Stop all active bots"""
        # Stop focus manager
        self.focus_manager_running = False
        if self.focus_manager_thread:
            self.focus_manager_thread.join(1.0)  # Wait up to 1 second
            self.focus_manager_thread = None
            
        # Stop all bots
        for task_id, thread in list(self.active_bots.items()):
            thread.stop()
            thread.wait()
        self.active_bots.clear()
        self.bot_queue.clear()
        self._notify_status_change()
    
    def get_status(self):
        """Get status of all bots"""
        return {
            'active': len(self.active_bots),
            'pending': len(self.bot_queue),
            'completed': self.completed_count,
            'active_bots': {id: 'Running' for id in self.active_bots.keys()},
            'progress': self.bot_progress,
            'errors': self.bot_errors
        }

class MultiBotDialog(QDialog):
    """Dialog for managing multiple bots"""
    
    def __init__(self, parent=None, bot_manager=None):
        super().__init__(parent)
        self.parent = parent
        self.bot_manager = bot_manager
        self.setWindowTitle("Multi-Bot Manager")
        self.setFixedSize(600, 500)  # Increased size for details
        
        self.setup_ui()
        
        # Update timer
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.update_status)
        self.timer.start(1000)  # Update every second
    
    def setup_ui(self):
        layout = QVBoxLayout(self)
        
        # Bot status
        status_layout = QHBoxLayout()
        
        # Stats
        self.stats_label = QLabel("Active: 0 | Pending: 0 | Completed: 0")
        status_layout.addWidget(self.stats_label)
        
        layout.addLayout(status_layout)
        
        # Split the main area into list and details
        list_details_layout = QHBoxLayout()
        
        # Bot list panel (left)
        list_panel = QVBoxLayout()
        list_panel.addWidget(QLabel("Active Bots:"))
        self.bot_list = QListWidget()
        self.bot_list.currentItemChanged.connect(self.bot_selected)
        list_panel.addWidget(self.bot_list)
        list_details_layout.addLayout(list_panel, 1)
        
        # Bot details panel (right)
        details_panel = QVBoxLayout()
        details_panel.addWidget(QLabel("Bot Details:"))
        self.bot_details = QTextEdit()
        self.bot_details.setReadOnly(True)
        details_panel.addWidget(self.bot_details)
        list_details_layout.addLayout(details_panel, 1)
        
        layout.addLayout(list_details_layout)
        
        # Controls
        controls_layout = QHBoxLayout()
        
        self.add_btn = QPushButton("Add Bot")
        self.add_btn.clicked.connect(self.add_bot)
        controls_layout.addWidget(self.add_btn)
        
        self.select_window_btn = QPushButton("Select Target Window")
        self.select_window_btn.clicked.connect(self.select_target_window)
        controls_layout.addWidget(self.select_window_btn)
        
        self.stop_btn = QPushButton("Stop Selected")
        self.stop_btn.clicked.connect(self.stop_selected)
        controls_layout.addWidget(self.stop_btn)
        
        self.stop_all_btn = QPushButton("Stop All")
        self.stop_all_btn.clicked.connect(self.stop_all)
        controls_layout.addWidget(self.stop_all_btn)
        
        layout.addLayout(controls_layout)
        
        # Store last selected window handle
        self.selected_window_handle = None
        self.selected_window_title = "No window selected"
        
        # Window selection status
        self.window_label = QLabel(f"Target Window: {self.selected_window_title}")
        layout.addWidget(self.window_label)
        
        self.update_status()
    
    def bot_selected(self):
        """Update details when a bot is selected"""
        if not self.bot_list.currentItem():
            self.bot_details.setText("")
            return
            
        # Get selected bot ID from item text (format: "ID: Status (Progress%)")
        selected_text = self.bot_list.currentItem().text()
        bot_id = selected_text.split(":")[0].strip()
        
        # Get status info
        status = self.bot_manager.get_status()
        
        # Prepare details text
        details = f"Bot: {bot_id}\n"
        details += f"Status: {'Running' if bot_id in self.bot_manager.active_bots else 'Completed'}\n"
        
        # Add progress if available
        if bot_id in status['progress']:
            progress = status['progress'][bot_id]
            details += f"Progress: {progress}%\n"
        
        # Add error log if available
        if bot_id in status['errors'] and status['errors'][bot_id]:
            details += "\nLast errors:\n"
            for error in status['errors'][bot_id]:
                details += f"- {error}\n"
                
        self.bot_details.setText(details)
    
    def select_target_window(self):
        """Let the user select a target window for bots"""
        # Show instructions to user
        QMessageBox.information(self, "Select Window", 
                             "Click OK, then click on the window where you want the bot to type.\n"
                             "You have 5 seconds to select a window.")
        
        # Hide this dialog temporarily
        self.hide()
        
        # Brief delay before starting to track
        time.sleep(0.5)
        
        # Timer for window selection
        start_time = time.time()
        while time.time() - start_time < 5.0:  # 5 seconds to select window
            time.sleep(0.1)  # Small delay to prevent CPU spike
            
            # Get current foreground window
            hwnd = user32.GetForegroundWindow()
            
            # Don't select our own app windows
            if hwnd and hwnd != self.winId() and (not self.parent or hwnd != self.parent.winId()):
                # Get window title
                title_len = user32.GetWindowTextLengthW(hwnd)
                if title_len > 0:
                    buff = ctypes.create_unicode_buffer(title_len + 1)
                    user32.GetWindowTextW(hwnd, buff, title_len + 1)
                    window_title = buff.value
                    
                    # Store the selected window
                    self.selected_window_handle = hwnd
                    self.selected_window_title = window_title
                    
                    # Update window label
                    self.window_label.setText(f"Target Window: {self.selected_window_title}")
                    
                    # Show dialog again
                    self.show()
                    
                    QMessageBox.information(self, "Window Selected", 
                                         f"Selected window: {window_title}\n\n"
                                         f"New bots will target this window.")
                    return
        
        # Show dialog again if no selection was made
        self.show()
        QMessageBox.warning(self, "No Window Selected", 
                          "No window was selected in time.\n"
                          "Bots will ask for a window click when started.")
    
    def add_bot(self):
        """Add a new bot with current settings from parent"""
        if not self.parent:
            return
            
        # Get a name for the bot
        name, ok = QInputDialog.getText(self, "Bot Name", "Enter a name for this bot:")
        if not ok or not name:
            name = None
            
        # Get settings from parent TypingBot
        settings = {
            'delay': self.parent.typing_speed,
            'error_rate': self.parent.error_rate,
            'punc_pause_prob': self.parent.punc_pause_prob,
            'space_pause_prob': self.parent.space_pause_prob,
            'thinking_pause_prob': self.parent.thinking_pause_prob,
            'background_mode': True,  # Always use background mode for multi-bot
            'notepad_mode': self.parent.notepad_mode_check.isChecked(),
            'word_memory': self.parent.word_memory
        }
        
        # Get text from parent's text edit
        text = self.parent.text_edit.toPlainText()
        if not text.strip():
            QMessageBox.warning(self, "No Text", "Please enter text to type in the main window.")
            return
            
        # Add to manager
        task_id = self.bot_manager.add_bot_task(text, settings, name)
        self.update_status()
        
        # Set target window if one is selected
        if self.selected_window_handle and task_id in self.bot_manager.active_bots:
            bot_thread = self.bot_manager.active_bots[task_id]
            if hasattr(bot_thread, 'set_target_window'):
                bot_thread.set_target_window(self.selected_window_handle)
                QMessageBox.information(self, "Bot Started", 
                                     f"Bot '{task_id}' started and targeting window: {self.selected_window_title}")
    
    def stop_selected(self):
        """Stop the selected bot"""
        if not self.bot_list.currentItem():
            return
            
        # Get the selected bot ID from the item text (format: "ID: Status")
        selected_text = self.bot_list.currentItem().text()
        bot_id = selected_text.split(":")[0].strip()
        
        self.bot_manager.stop_bot(bot_id)
        self.update_status()
    
    def stop_all(self):
        """Stop all bots"""
        self.bot_manager.stop_all()
        self.update_status()
    
    def update_status(self):
        """Update the status display"""
        status = self.bot_manager.get_status()
        
        # Update stats
        self.stats_label.setText(
            f"Active: {status['active']} | "
            f"Pending: {len(self.bot_manager.bot_queue)} | "
            f"Completed: {status['completed']}"
        )
        
        # Save currently selected item text
        current_selection = None
        if self.bot_list.currentItem():
            current_selection = self.bot_list.currentItem().text().split(":")[0].strip()
        
        # Update bot list
        self.bot_list.clear()
        for bot_id, state in status['active_bots'].items():
            # Add progress if available
            progress_text = ""
            if bot_id in status['progress']:
                progress = status['progress'][bot_id]
                progress_text = f" ({progress}%)"
                
            self.bot_list.addItem(f"{bot_id}: {state}{progress_text}")
        
        # Try to reselect the previously selected bot
        if current_selection:
            for i in range(self.bot_list.count()):
                item_text = self.bot_list.item(i).text()
                if item_text.startswith(f"{current_selection}:"):
                    self.bot_list.setCurrentRow(i)
                    break
        
        # Update the details view if a bot is selected
        self.bot_selected()

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = TypingBot()
    window.show()
    sys.exit(app.exec_())

# Packaging instructions:
# 1. pip install pyinstaller
# 2. pyinstaller --onefile --windowed main.py
# This creates a user-friendly EXE without opening VSCode.
